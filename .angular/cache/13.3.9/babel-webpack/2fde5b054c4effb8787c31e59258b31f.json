{"ast":null,"code":"import _slicedToArray from \"/home/satyanayak610/Satya/Projects/AngularApexDashboard/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/home/satyanayak610/Satya/Projects/AngularApexDashboard/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _inherits from \"/home/satyanayak610/Satya/Projects/AngularApexDashboard/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/satyanayak610/Satya/Projects/AngularApexDashboard/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _createClass from \"/home/satyanayak610/Satya/Projects/AngularApexDashboard/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/home/satyanayak610/Satya/Projects/AngularApexDashboard/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\n\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n\nimport * as i0 from '@angular/core';\nimport { Injectable, Optional, Inject, NgModule, InjectionToken } from '@angular/core';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpParams, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { __awaiter } from 'tslib';\nimport { Subject, of, from, race, throwError, combineLatest, merge } from 'rxjs';\nimport { filter, tap, debounceTime, delay, switchMap, map, first, catchError, timeout, take, mergeMap } from 'rxjs/operators';\nimport fsha256 from 'fast-sha256';\n\nvar DateTimeProvider = /*#__PURE__*/_createClass(function DateTimeProvider() {\n  _classCallCheck(this, DateTimeProvider);\n});\n\nvar SystemDateTimeProvider = /*#__PURE__*/(function () {\n  var SystemDateTimeProvider = /*#__PURE__*/function (_DateTimeProvider) {\n    _inherits(SystemDateTimeProvider, _DateTimeProvider);\n\n    var _super = _createSuper(SystemDateTimeProvider);\n\n    function SystemDateTimeProvider() {\n      _classCallCheck(this, SystemDateTimeProvider);\n\n      return _super.apply(this, arguments);\n    }\n\n    _createClass(SystemDateTimeProvider, [{\n      key: \"now\",\n      value: function now() {\n        return Date.now();\n      }\n    }, {\n      key: \"new\",\n      value: function _new() {\n        return new Date();\n      }\n    }]);\n\n    return SystemDateTimeProvider;\n  }(DateTimeProvider);\n\n  SystemDateTimeProvider.ɵfac = /* @__PURE__ */function () {\n    var ɵSystemDateTimeProvider_BaseFactory;\n    return function SystemDateTimeProvider_Factory(t) {\n      return (ɵSystemDateTimeProvider_BaseFactory || (ɵSystemDateTimeProvider_BaseFactory = i0.ɵɵgetInheritedFactory(SystemDateTimeProvider)))(t || SystemDateTimeProvider);\n    };\n  }();\n\n  SystemDateTimeProvider.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SystemDateTimeProvider,\n    factory: SystemDateTimeProvider.ɵfac\n  });\n  return SystemDateTimeProvider;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * Additional options that can be passed to tryLogin.\r\n */\n\n\nvar LoginOptions = /*#__PURE__*/_createClass(function LoginOptions() {\n  _classCallCheck(this, LoginOptions);\n\n  /**\r\n   * Set this to true to disable the nonce\r\n   * check which is used to avoid\r\n   * replay attacks.\r\n   * This flag should never be true in\r\n   * production environments.\r\n   */\n  this.disableNonceCheck = false;\n  /**\r\n   * Normally, you want to clear your hash fragment after\r\n   * the lib read the token(s) so that they are not displayed\r\n   * anymore in the url. If not, set this to true. For code flow\r\n   * this controls removing query string values.\r\n   */\n\n  this.preventClearHashAfterLogin = false;\n});\n/**\r\n * Defines the logging interface the OAuthService uses\r\n * internally. Is compatible with the `console` object,\r\n * but you can provide your own implementation as well\r\n * through dependency injection.\r\n */\n\n\nvar OAuthLogger = /*#__PURE__*/_createClass(function OAuthLogger() {\n  _classCallCheck(this, OAuthLogger);\n});\n/**\r\n * Defines a simple storage that can be used for\r\n * storing the tokens at client side.\r\n * Is compatible to localStorage and sessionStorage,\r\n * but you can also create your own implementations.\r\n */\n\n\nvar OAuthStorage = /*#__PURE__*/_createClass(function OAuthStorage() {\n  _classCallCheck(this, OAuthStorage);\n});\n\nvar MemoryStorage = /*#__PURE__*/(function () {\n  var MemoryStorage = /*#__PURE__*/function () {\n    function MemoryStorage() {\n      _classCallCheck(this, MemoryStorage);\n\n      this.data = new Map();\n    }\n\n    _createClass(MemoryStorage, [{\n      key: \"getItem\",\n      value: function getItem(key) {\n        return this.data.get(key);\n      }\n    }, {\n      key: \"removeItem\",\n      value: function removeItem(key) {\n        this.data.delete(key);\n      }\n    }, {\n      key: \"setItem\",\n      value: function setItem(key, data) {\n        this.data.set(key, data);\n      }\n    }]);\n\n    return MemoryStorage;\n  }();\n\n  MemoryStorage.ɵfac = function MemoryStorage_Factory(t) {\n    return new (t || MemoryStorage)();\n  };\n\n  MemoryStorage.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MemoryStorage,\n    factory: MemoryStorage.ɵfac\n  });\n  return MemoryStorage;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * Represents the received tokens, the received state\r\n * and the parsed claims from the id-token.\r\n */\n\n\nvar ReceivedTokens = /*#__PURE__*/_createClass(function ReceivedTokens() {\n  _classCallCheck(this, ReceivedTokens);\n});\n\nvar OAuthEvent = /*#__PURE__*/_createClass(function OAuthEvent(type) {\n  _classCallCheck(this, OAuthEvent);\n\n  this.type = type;\n});\n\nvar OAuthSuccessEvent = /*#__PURE__*/function (_OAuthEvent) {\n  _inherits(OAuthSuccessEvent, _OAuthEvent);\n\n  var _super2 = _createSuper(OAuthSuccessEvent);\n\n  function OAuthSuccessEvent(type) {\n    var _this;\n\n    var info = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, OAuthSuccessEvent);\n\n    _this = _super2.call(this, type);\n    _this.info = info;\n    return _this;\n  }\n\n  return _createClass(OAuthSuccessEvent);\n}(OAuthEvent);\n\nvar OAuthInfoEvent = /*#__PURE__*/function (_OAuthEvent2) {\n  _inherits(OAuthInfoEvent, _OAuthEvent2);\n\n  var _super3 = _createSuper(OAuthInfoEvent);\n\n  function OAuthInfoEvent(type) {\n    var _this2;\n\n    var info = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, OAuthInfoEvent);\n\n    _this2 = _super3.call(this, type);\n    _this2.info = info;\n    return _this2;\n  }\n\n  return _createClass(OAuthInfoEvent);\n}(OAuthEvent);\n\nvar OAuthErrorEvent = /*#__PURE__*/function (_OAuthEvent3) {\n  _inherits(OAuthErrorEvent, _OAuthEvent3);\n\n  var _super4 = _createSuper(OAuthErrorEvent);\n\n  function OAuthErrorEvent(type, reason) {\n    var _this3;\n\n    var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    _classCallCheck(this, OAuthErrorEvent);\n\n    _this3 = _super4.call(this, type);\n    _this3.reason = reason;\n    _this3.params = params;\n    return _this3;\n  }\n\n  return _createClass(OAuthErrorEvent);\n}(OAuthEvent); // see: https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_.22Unicode_Problem.22\n\n\nfunction b64DecodeUnicode(str) {\n  var base64 = str.replace(/\\-/g, '+').replace(/\\_/g, '/');\n  return decodeURIComponent(atob(base64).split('').map(function (c) {\n    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n  }).join(''));\n}\n\nfunction base64UrlEncode(str) {\n  var base64 = btoa(str);\n  return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nvar AuthConfig = /*#__PURE__*/_createClass(function AuthConfig(json) {\n  _classCallCheck(this, AuthConfig);\n\n  /**\r\n   * The client's id as registered with the auth server\r\n   */\n  this.clientId = '';\n  /**\r\n   * The client's redirectUri as registered with the auth server\r\n   */\n\n  this.redirectUri = '';\n  /**\r\n   * An optional second redirectUri where the auth server\r\n   * redirects the user to after logging out.\r\n   */\n\n  this.postLogoutRedirectUri = '';\n  /**\r\n   * Defines whether to use 'redirectUri' as a replacement\r\n   * of 'postLogoutRedirectUri' if the latter is not set.\r\n   */\n\n  this.redirectUriAsPostLogoutRedirectUriFallback = true;\n  /**\r\n   * The auth server's endpoint that allows to log\r\n   * the user in when using implicit flow.\r\n   */\n\n  this.loginUrl = '';\n  /**\r\n   * The requested scopes\r\n   */\n\n  this.scope = 'openid profile';\n  this.resource = '';\n  this.rngUrl = '';\n  /**\r\n   * Defines whether to use OpenId Connect during\r\n   * implicit flow.\r\n   */\n\n  this.oidc = true;\n  /**\r\n   * Defines whether to request an access token during\r\n   * implicit flow.\r\n   */\n\n  this.requestAccessToken = true;\n  this.options = null;\n  /**\r\n   * The issuer's uri.\r\n   */\n\n  this.issuer = '';\n  /**\r\n   * The logout url.\r\n   */\n\n  this.logoutUrl = '';\n  /**\r\n   * Defines whether to clear the hash fragment after logging in.\r\n   */\n\n  this.clearHashAfterLogin = true;\n  /**\r\n   * Url of the token endpoint as defined by OpenId Connect and OAuth 2.\r\n   */\n\n  this.tokenEndpoint = null;\n  /**\r\n   * Url of the revocation endpoint as defined by OpenId Connect and OAuth 2.\r\n   */\n\n  this.revocationEndpoint = null;\n  /**\r\n   * Names of known parameters sent out in the TokenResponse. https://tools.ietf.org/html/rfc6749#section-5.1\r\n   */\n\n  this.customTokenParameters = [];\n  /**\r\n   * Url of the userinfo endpoint as defined by OpenId Connect.\r\n   */\n\n  this.userinfoEndpoint = null;\n  this.responseType = '';\n  /**\r\n   * Defines whether additional debug information should\r\n   * be shown at the console. Note that in certain browsers\r\n   * the verbosity of the console needs to be explicitly set\r\n   * to include Debug level messages.\r\n   */\n\n  this.showDebugInformation = false;\n  /**\r\n   * The redirect uri used when doing silent refresh.\r\n   */\n\n  this.silentRefreshRedirectUri = '';\n  this.silentRefreshMessagePrefix = '';\n  /**\r\n   * Set this to true to display the iframe used for\r\n   * silent refresh for debugging.\r\n   */\n\n  this.silentRefreshShowIFrame = false;\n  /**\r\n   * Timeout for silent refresh.\r\n   * @internal\r\n   * depreacted b/c of typo, see silentRefreshTimeout\r\n   */\n\n  this.siletRefreshTimeout = 1000 * 20;\n  /**\r\n   * Timeout for silent refresh.\r\n   */\n\n  this.silentRefreshTimeout = 1000 * 20;\n  /**\r\n   * Some auth servers don't allow using password flow\r\n   * w/o a client secret while the standards do not\r\n   * demand for it. In this case, you can set a password\r\n   * here. As this password is exposed to the public\r\n   * it does not bring additional security and is therefore\r\n   * as good as using no password.\r\n   */\n\n  this.dummyClientSecret = null;\n  /**\r\n   * Defines whether https is required.\r\n   * The default value is remoteOnly which only allows\r\n   * http for localhost, while every other domains need\r\n   * to be used with https.\r\n   */\n\n  this.requireHttps = 'remoteOnly';\n  /**\r\n   * Defines whether every url provided by the discovery\r\n   * document has to start with the issuer's url.\r\n   */\n\n  this.strictDiscoveryDocumentValidation = true;\n  /**\r\n   * JSON Web Key Set (https://tools.ietf.org/html/rfc7517)\r\n   * with keys used to validate received id_tokens.\r\n   * This is taken out of the disovery document. Can be set manually too.\r\n   */\n\n  this.jwks = null;\n  /**\r\n   * Map with additional query parameter that are appended to\r\n   * the request when initializing implicit flow.\r\n   */\n\n  this.customQueryParams = null;\n  this.silentRefreshIFrameName = 'angular-oauth-oidc-silent-refresh-iframe';\n  /**\r\n   * Defines when the token_timeout event should be raised.\r\n   * If you set this to the default value 0.75, the event\r\n   * is triggered after 75% of the token's life time.\r\n   */\n\n  this.timeoutFactor = 0.75;\n  /**\r\n   * If true, the lib will try to check whether the user\r\n   * is still logged in on a regular basis as described\r\n   * in http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification\r\n   */\n\n  this.sessionChecksEnabled = false;\n  /**\r\n   * Interval in msec for checking the session\r\n   * according to http://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification\r\n   */\n\n  this.sessionCheckIntervall = 3 * 1000;\n  /**\r\n   * Url for the iframe used for session checks\r\n   */\n\n  this.sessionCheckIFrameUrl = null;\n  /**\r\n   * Name of the iframe to use for session checks\r\n   */\n\n  this.sessionCheckIFrameName = 'angular-oauth-oidc-check-session-iframe';\n  /**\r\n   * This property has been introduced to disable at_hash checks\r\n   * and is indented for Identity Provider that does not deliver\r\n   * an at_hash EVEN THOUGH its recommended by the OIDC specs.\r\n   * Of course, when disabling these checks then we are bypassing\r\n   * a security check which means we are more vulnerable.\r\n   */\n\n  this.disableAtHashCheck = false;\n  /**\r\n   * Defines wether to check the subject of a refreshed token after silent refresh.\r\n   * Normally, it should be the same as before.\r\n   */\n\n  this.skipSubjectCheck = false;\n  this.useIdTokenHintForSilentRefresh = false;\n  /**\r\n   * Defined whether to skip the validation of the issuer in the discovery document.\r\n   * Normally, the discovey document's url starts with the url of the issuer.\r\n   */\n\n  this.skipIssuerCheck = false;\n  /**\r\n   * final state sent to issuer is built as follows:\r\n   * state = nonce + nonceStateSeparator + additional state\r\n   * Default separator is ';' (encoded %3B).\r\n   * In rare cases, this character might be forbidden or inconvenient to use by the issuer so it can be customized.\r\n   */\n\n  this.nonceStateSeparator = ';';\n  /**\r\n   * Set this to true to use HTTP BASIC auth for AJAX calls\r\n   */\n\n  this.useHttpBasicAuth = false;\n  /**\r\n   * The interceptors waits this time span if there is no token\r\n   */\n\n  this.waitForTokenInMsec = 0;\n  /**\r\n   * Code Flow is by defauld used together with PKCI which is also higly recommented.\r\n   * You can disbale it here by setting this flag to true.\r\n   * https://tools.ietf.org/html/rfc7636#section-1.1\r\n   */\n\n  this.disablePKCE = false;\n  /**\r\n   * Set this to true to preserve the requested route including query parameters after code flow login.\r\n   * This setting enables deep linking for the code flow.\r\n   */\n\n  this.preserveRequestedRoute = false;\n  /**\r\n   * This property allows you to override the method that is used to open the login url,\r\n   * allowing a way for implementations to specify their own method of routing to new\r\n   * urls.\r\n   */\n\n  this.openUri = function (uri) {\n    location.href = uri;\n  };\n\n  if (json) {\n    Object.assign(this, json);\n  }\n});\n/**\r\n * This custom encoder allows charactes like +, % and / to be used in passwords\r\n */\n\n\nvar WebHttpUrlEncodingCodec = /*#__PURE__*/function () {\n  function WebHttpUrlEncodingCodec() {\n    _classCallCheck(this, WebHttpUrlEncodingCodec);\n  }\n\n  _createClass(WebHttpUrlEncodingCodec, [{\n    key: \"encodeKey\",\n    value: function encodeKey(k) {\n      return encodeURIComponent(k);\n    }\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(v) {\n      return encodeURIComponent(v);\n    }\n  }, {\n    key: \"decodeKey\",\n    value: function decodeKey(k) {\n      return decodeURIComponent(k);\n    }\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(v) {\n      return decodeURIComponent(v);\n    }\n  }]);\n\n  return WebHttpUrlEncodingCodec;\n}();\n/**\r\n * Interface for Handlers that are hooked in to\r\n * validate tokens.\r\n */\n\n\nvar ValidationHandler = /*#__PURE__*/_createClass(function ValidationHandler() {\n  _classCallCheck(this, ValidationHandler);\n});\n/**\r\n * This abstract implementation of ValidationHandler already implements\r\n * the method validateAtHash. However, to make use of it,\r\n * you have to override the method calcHash.\r\n */\n\n\nvar AbstractValidationHandler = /*#__PURE__*/function () {\n  function AbstractValidationHandler() {\n    _classCallCheck(this, AbstractValidationHandler);\n  }\n\n  _createClass(AbstractValidationHandler, [{\n    key: \"validateAtHash\",\n    value:\n    /**\r\n     * Validates the at_hash in an id_token against the received access_token.\r\n     */\n    function validateAtHash(params) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var hashAlg, tokenHash, leftMostHalf, atHash, claimsAtHash;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                hashAlg = this.inferHashAlgorithm(params.idTokenHeader);\n                _context.next = 3;\n                return this.calcHash(params.accessToken, hashAlg);\n\n              case 3:\n                tokenHash = _context.sent;\n                // sha256(accessToken, { asString: true });\n                leftMostHalf = tokenHash.substr(0, tokenHash.length / 2);\n                atHash = base64UrlEncode(leftMostHalf);\n                claimsAtHash = params.idTokenClaims['at_hash'].replace(/=/g, '');\n\n                if (atHash !== claimsAtHash) {\n                  console.error('exptected at_hash: ' + atHash);\n                  console.error('actual at_hash: ' + claimsAtHash);\n                }\n\n                return _context.abrupt(\"return\", atHash === claimsAtHash);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\r\n     * Infers the name of the hash algorithm to use\r\n     * from the alg field of an id_token.\r\n     *\r\n     * @param jwtHeader the id_token's parsed header\r\n     */\n\n  }, {\n    key: \"inferHashAlgorithm\",\n    value: function inferHashAlgorithm(jwtHeader) {\n      var alg = jwtHeader['alg'];\n\n      if (!alg.match(/^.S[0-9]{3}$/)) {\n        throw new Error('Algorithm not supported: ' + alg);\n      }\n\n      return 'sha-' + alg.substr(2);\n    }\n  }]);\n\n  return AbstractValidationHandler;\n}();\n\nvar UrlHelperService = /*#__PURE__*/(function () {\n  var UrlHelperService = /*#__PURE__*/function () {\n    function UrlHelperService() {\n      _classCallCheck(this, UrlHelperService);\n    }\n\n    _createClass(UrlHelperService, [{\n      key: \"getHashFragmentParams\",\n      value: function getHashFragmentParams(customHashFragment) {\n        var hash = customHashFragment || window.location.hash;\n        hash = decodeURIComponent(hash);\n\n        if (hash.indexOf('#') !== 0) {\n          return {};\n        }\n\n        var questionMarkPosition = hash.indexOf('?');\n\n        if (questionMarkPosition > -1) {\n          hash = hash.substr(questionMarkPosition + 1);\n        } else {\n          hash = hash.substr(1);\n        }\n\n        return this.parseQueryString(hash);\n      }\n    }, {\n      key: \"parseQueryString\",\n      value: function parseQueryString(queryString) {\n        var data = {};\n        var pairs, pair, separatorIndex, escapedKey, escapedValue, key, value;\n\n        if (queryString === null) {\n          return data;\n        }\n\n        pairs = queryString.split('&');\n\n        for (var i = 0; i < pairs.length; i++) {\n          pair = pairs[i];\n          separatorIndex = pair.indexOf('=');\n\n          if (separatorIndex === -1) {\n            escapedKey = pair;\n            escapedValue = null;\n          } else {\n            escapedKey = pair.substr(0, separatorIndex);\n            escapedValue = pair.substr(separatorIndex + 1);\n          }\n\n          key = decodeURIComponent(escapedKey);\n          value = decodeURIComponent(escapedValue);\n\n          if (key.substr(0, 1) === '/') {\n            key = key.substr(1);\n          }\n\n          data[key] = value;\n        }\n\n        return data;\n      }\n    }]);\n\n    return UrlHelperService;\n  }();\n\n  UrlHelperService.ɵfac = function UrlHelperService_Factory(t) {\n    return new (t || UrlHelperService)();\n  };\n\n  UrlHelperService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: UrlHelperService,\n    factory: UrlHelperService.ɵfac\n  });\n  return UrlHelperService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * [js-sha256]{@link https://github.com/emn178/js-sha256}\r\n *\r\n * @version 0.9.0\r\n * @author Chen, Yi-Cyuan [emn178@gmail.com]\r\n * @copyright Chen, Yi-Cyuan 2014-2017\r\n * @license MIT\r\n */\n\n/*jslint bitwise: true */\n\n\nfunction factory() {\n  var ERROR = 'input is invalid type';\n  var WINDOW = typeof window === 'object';\n  var root = WINDOW ? window : {};\n\n  if (root.JS_SHA256_NO_WINDOW) {\n    WINDOW = false;\n  }\n\n  var WEB_WORKER = !WINDOW && typeof self === 'object';\n  var NODE_JS = !root.JS_SHA256_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;\n\n  if (NODE_JS) {\n    root = global;\n  } else if (WEB_WORKER) {\n    root = self;\n  }\n\n  var COMMON_JS = !root.JS_SHA256_NO_COMMON_JS && typeof module === 'object' && module.exports;\n  var AMD = typeof define === 'function' && define.amd;\n  var ARRAY_BUFFER = !root.JS_SHA256_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';\n  var HEX_CHARS = '0123456789abcdef'.split('');\n  var EXTRA = [-2147483648, 8388608, 32768, 128];\n  var SHIFT = [24, 16, 8, 0];\n  var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];\n  var OUTPUT_TYPES = ['hex', 'array', 'digest', 'arrayBuffer'];\n  var blocks = [];\n\n  if (root.JS_SHA256_NO_NODE_JS || !Array.isArray) {\n    Array.isArray = function (obj) {\n      return Object.prototype.toString.call(obj) === '[object Array]';\n    };\n  }\n\n  if (ARRAY_BUFFER && (root.JS_SHA256_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {\n    ArrayBuffer.isView = function (obj) {\n      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;\n    };\n  }\n\n  var createOutputMethod = function createOutputMethod(outputType, is224) {\n    return function (message) {\n      return new Sha256(is224, true).update(message)[outputType]();\n    };\n  };\n\n  var createMethod = function createMethod(is224) {\n    var method = createOutputMethod('hex', is224);\n\n    if (NODE_JS) {\n      method = nodeWrap(method, is224);\n    }\n\n    method.create = function () {\n      return new Sha256(is224);\n    };\n\n    method.update = function (message) {\n      return method.create().update(message);\n    };\n\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createOutputMethod(type, is224);\n    }\n\n    return method;\n  };\n\n  var nodeWrap = function nodeWrap(method, is224) {\n    var crypto = eval(\"require('crypto')\");\n    var Buffer = eval(\"require('buffer').Buffer\");\n    var algorithm = is224 ? 'sha224' : 'sha256';\n\n    var nodeMethod = function nodeMethod(message) {\n      if (typeof message === 'string') {\n        return crypto.createHash(algorithm).update(message, 'utf8').digest('hex');\n      } else {\n        if (message === null || message === undefined) {\n          throw new Error(ERROR);\n        } else if (message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        }\n      }\n\n      if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {\n        return crypto.createHash(algorithm).update(new Buffer(message)).digest('hex');\n      } else {\n        return method(message);\n      }\n    };\n\n    return nodeMethod;\n  };\n\n  var createHmacOutputMethod = function createHmacOutputMethod(outputType, is224) {\n    return function (key, message) {\n      return new HmacSha256(key, is224, true).update(message)[outputType]();\n    };\n  };\n\n  var createHmacMethod = function createHmacMethod(is224) {\n    var method = createHmacOutputMethod('hex', is224);\n\n    method.create = function (key) {\n      return new HmacSha256(key, is224);\n    };\n\n    method.update = function (key, message) {\n      return method.create(key).update(message);\n    };\n\n    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\n      var type = OUTPUT_TYPES[i];\n      method[type] = createHmacOutputMethod(type, is224);\n    }\n\n    return method;\n  };\n\n  function Sha256(is224, sharedMemory) {\n    if (sharedMemory) {\n      blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      this.blocks = blocks;\n    } else {\n      this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    }\n\n    if (is224) {\n      this.h0 = 0xc1059ed8;\n      this.h1 = 0x367cd507;\n      this.h2 = 0x3070dd17;\n      this.h3 = 0xf70e5939;\n      this.h4 = 0xffc00b31;\n      this.h5 = 0x68581511;\n      this.h6 = 0x64f98fa7;\n      this.h7 = 0xbefa4fa4;\n    } else {\n      // 256\n      this.h0 = 0x6a09e667;\n      this.h1 = 0xbb67ae85;\n      this.h2 = 0x3c6ef372;\n      this.h3 = 0xa54ff53a;\n      this.h4 = 0x510e527f;\n      this.h5 = 0x9b05688c;\n      this.h6 = 0x1f83d9ab;\n      this.h7 = 0x5be0cd19;\n    }\n\n    this.block = this.start = this.bytes = this.hBytes = 0;\n    this.finalized = this.hashed = false;\n    this.first = true;\n    this.is224 = is224;\n  }\n\n  Sha256.prototype.update = function (message) {\n    if (this.finalized) {\n      return;\n    }\n\n    var notString,\n        type = typeof message;\n\n    if (type !== 'string') {\n      if (type === 'object') {\n        if (message === null) {\n          throw new Error(ERROR);\n        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {\n          message = new Uint8Array(message);\n        } else if (!Array.isArray(message)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {\n            throw new Error(ERROR);\n          }\n        }\n      } else {\n        throw new Error(ERROR);\n      }\n\n      notString = true;\n    }\n\n    var code,\n        index = 0,\n        i,\n        length = message.length,\n        blocks = this.blocks;\n\n    while (index < length) {\n      if (this.hashed) {\n        this.hashed = false;\n        blocks[0] = this.block;\n        blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n      }\n\n      if (notString) {\n        for (i = this.start; index < length && i < 64; ++index) {\n          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\n        }\n      } else {\n        for (i = this.start; index < length && i < 64; ++index) {\n          code = message.charCodeAt(index);\n\n          if (code < 0x80) {\n            blocks[i >> 2] |= code << SHIFT[i++ & 3];\n          } else if (code < 0x800) {\n            blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];\n          } else if (code < 0xd800 || code >= 0xe000) {\n            blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];\n          } else {\n            code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);\n            blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];\n            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];\n          }\n        }\n      }\n\n      this.lastByteIndex = i;\n      this.bytes += i - this.start;\n\n      if (i >= 64) {\n        this.block = blocks[16];\n        this.start = i - 64;\n        this.hash();\n        this.hashed = true;\n      } else {\n        this.start = i;\n      }\n    }\n\n    if (this.bytes > 4294967295) {\n      this.hBytes += this.bytes / 4294967296 << 0;\n      this.bytes = this.bytes % 4294967296;\n    }\n\n    return this;\n  };\n\n  Sha256.prototype.finalize = function () {\n    if (this.finalized) {\n      return;\n    }\n\n    this.finalized = true;\n    var blocks = this.blocks,\n        i = this.lastByteIndex;\n    blocks[16] = this.block;\n    blocks[i >> 2] |= EXTRA[i & 3];\n    this.block = blocks[16];\n\n    if (i >= 56) {\n      if (!this.hashed) {\n        this.hash();\n      }\n\n      blocks[0] = this.block;\n      blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;\n    }\n\n    blocks[14] = this.hBytes << 3 | this.bytes >>> 29;\n    blocks[15] = this.bytes << 3;\n    this.hash();\n  };\n\n  Sha256.prototype.hash = function () {\n    var a = this.h0,\n        b = this.h1,\n        c = this.h2,\n        d = this.h3,\n        e = this.h4,\n        f = this.h5,\n        g = this.h6,\n        h = this.h7,\n        blocks = this.blocks,\n        j,\n        s0,\n        s1,\n        maj,\n        t1,\n        t2,\n        ch,\n        ab,\n        da,\n        cd,\n        bc;\n\n    for (j = 16; j < 64; ++j) {\n      // rightrotate\n      t1 = blocks[j - 15];\n      s0 = (t1 >>> 7 | t1 << 25) ^ (t1 >>> 18 | t1 << 14) ^ t1 >>> 3;\n      t1 = blocks[j - 2];\n      s1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;\n      blocks[j] = blocks[j - 16] + s0 + blocks[j - 7] + s1 << 0;\n    }\n\n    bc = b & c;\n\n    for (j = 0; j < 64; j += 4) {\n      if (this.first) {\n        if (this.is224) {\n          ab = 300032;\n          t1 = blocks[0] - 1413257819;\n          h = t1 - 150054599 << 0;\n          d = t1 + 24177077 << 0;\n        } else {\n          ab = 704751109;\n          t1 = blocks[0] - 210244248;\n          h = t1 - 1521486534 << 0;\n          d = t1 + 143694565 << 0;\n        }\n\n        this.first = false;\n      } else {\n        s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);\n        s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);\n        ab = a & b;\n        maj = ab ^ a & c ^ bc;\n        ch = e & f ^ ~e & g;\n        t1 = h + s1 + ch + K[j] + blocks[j];\n        t2 = s0 + maj;\n        h = d + t1 << 0;\n        d = t1 + t2 << 0;\n      }\n\n      s0 = (d >>> 2 | d << 30) ^ (d >>> 13 | d << 19) ^ (d >>> 22 | d << 10);\n      s1 = (h >>> 6 | h << 26) ^ (h >>> 11 | h << 21) ^ (h >>> 25 | h << 7);\n      da = d & a;\n      maj = da ^ d & b ^ ab;\n      ch = h & e ^ ~h & f;\n      t1 = g + s1 + ch + K[j + 1] + blocks[j + 1];\n      t2 = s0 + maj;\n      g = c + t1 << 0;\n      c = t1 + t2 << 0;\n      s0 = (c >>> 2 | c << 30) ^ (c >>> 13 | c << 19) ^ (c >>> 22 | c << 10);\n      s1 = (g >>> 6 | g << 26) ^ (g >>> 11 | g << 21) ^ (g >>> 25 | g << 7);\n      cd = c & d;\n      maj = cd ^ c & a ^ da;\n      ch = g & h ^ ~g & e;\n      t1 = f + s1 + ch + K[j + 2] + blocks[j + 2];\n      t2 = s0 + maj;\n      f = b + t1 << 0;\n      b = t1 + t2 << 0;\n      s0 = (b >>> 2 | b << 30) ^ (b >>> 13 | b << 19) ^ (b >>> 22 | b << 10);\n      s1 = (f >>> 6 | f << 26) ^ (f >>> 11 | f << 21) ^ (f >>> 25 | f << 7);\n      bc = b & c;\n      maj = bc ^ b & d ^ cd;\n      ch = f & g ^ ~f & h;\n      t1 = e + s1 + ch + K[j + 3] + blocks[j + 3];\n      t2 = s0 + maj;\n      e = a + t1 << 0;\n      a = t1 + t2 << 0;\n    }\n\n    this.h0 = this.h0 + a << 0;\n    this.h1 = this.h1 + b << 0;\n    this.h2 = this.h2 + c << 0;\n    this.h3 = this.h3 + d << 0;\n    this.h4 = this.h4 + e << 0;\n    this.h5 = this.h5 + f << 0;\n    this.h6 = this.h6 + g << 0;\n    this.h7 = this.h7 + h << 0;\n  };\n\n  Sha256.prototype.hex = function () {\n    this.finalize();\n    var h0 = this.h0,\n        h1 = this.h1,\n        h2 = this.h2,\n        h3 = this.h3,\n        h4 = this.h4,\n        h5 = this.h5,\n        h6 = this.h6,\n        h7 = this.h7;\n    var hex = HEX_CHARS[h0 >> 28 & 0x0F] + HEX_CHARS[h0 >> 24 & 0x0F] + HEX_CHARS[h0 >> 20 & 0x0F] + HEX_CHARS[h0 >> 16 & 0x0F] + HEX_CHARS[h0 >> 12 & 0x0F] + HEX_CHARS[h0 >> 8 & 0x0F] + HEX_CHARS[h0 >> 4 & 0x0F] + HEX_CHARS[h0 & 0x0F] + HEX_CHARS[h1 >> 28 & 0x0F] + HEX_CHARS[h1 >> 24 & 0x0F] + HEX_CHARS[h1 >> 20 & 0x0F] + HEX_CHARS[h1 >> 16 & 0x0F] + HEX_CHARS[h1 >> 12 & 0x0F] + HEX_CHARS[h1 >> 8 & 0x0F] + HEX_CHARS[h1 >> 4 & 0x0F] + HEX_CHARS[h1 & 0x0F] + HEX_CHARS[h2 >> 28 & 0x0F] + HEX_CHARS[h2 >> 24 & 0x0F] + HEX_CHARS[h2 >> 20 & 0x0F] + HEX_CHARS[h2 >> 16 & 0x0F] + HEX_CHARS[h2 >> 12 & 0x0F] + HEX_CHARS[h2 >> 8 & 0x0F] + HEX_CHARS[h2 >> 4 & 0x0F] + HEX_CHARS[h2 & 0x0F] + HEX_CHARS[h3 >> 28 & 0x0F] + HEX_CHARS[h3 >> 24 & 0x0F] + HEX_CHARS[h3 >> 20 & 0x0F] + HEX_CHARS[h3 >> 16 & 0x0F] + HEX_CHARS[h3 >> 12 & 0x0F] + HEX_CHARS[h3 >> 8 & 0x0F] + HEX_CHARS[h3 >> 4 & 0x0F] + HEX_CHARS[h3 & 0x0F] + HEX_CHARS[h4 >> 28 & 0x0F] + HEX_CHARS[h4 >> 24 & 0x0F] + HEX_CHARS[h4 >> 20 & 0x0F] + HEX_CHARS[h4 >> 16 & 0x0F] + HEX_CHARS[h4 >> 12 & 0x0F] + HEX_CHARS[h4 >> 8 & 0x0F] + HEX_CHARS[h4 >> 4 & 0x0F] + HEX_CHARS[h4 & 0x0F] + HEX_CHARS[h5 >> 28 & 0x0F] + HEX_CHARS[h5 >> 24 & 0x0F] + HEX_CHARS[h5 >> 20 & 0x0F] + HEX_CHARS[h5 >> 16 & 0x0F] + HEX_CHARS[h5 >> 12 & 0x0F] + HEX_CHARS[h5 >> 8 & 0x0F] + HEX_CHARS[h5 >> 4 & 0x0F] + HEX_CHARS[h5 & 0x0F] + HEX_CHARS[h6 >> 28 & 0x0F] + HEX_CHARS[h6 >> 24 & 0x0F] + HEX_CHARS[h6 >> 20 & 0x0F] + HEX_CHARS[h6 >> 16 & 0x0F] + HEX_CHARS[h6 >> 12 & 0x0F] + HEX_CHARS[h6 >> 8 & 0x0F] + HEX_CHARS[h6 >> 4 & 0x0F] + HEX_CHARS[h6 & 0x0F];\n\n    if (!this.is224) {\n      hex += HEX_CHARS[h7 >> 28 & 0x0F] + HEX_CHARS[h7 >> 24 & 0x0F] + HEX_CHARS[h7 >> 20 & 0x0F] + HEX_CHARS[h7 >> 16 & 0x0F] + HEX_CHARS[h7 >> 12 & 0x0F] + HEX_CHARS[h7 >> 8 & 0x0F] + HEX_CHARS[h7 >> 4 & 0x0F] + HEX_CHARS[h7 & 0x0F];\n    }\n\n    return hex;\n  };\n\n  Sha256.prototype.toString = Sha256.prototype.hex;\n\n  Sha256.prototype.digest = function () {\n    this.finalize();\n    var h0 = this.h0,\n        h1 = this.h1,\n        h2 = this.h2,\n        h3 = this.h3,\n        h4 = this.h4,\n        h5 = this.h5,\n        h6 = this.h6,\n        h7 = this.h7;\n    var arr = [h0 >> 24 & 0xFF, h0 >> 16 & 0xFF, h0 >> 8 & 0xFF, h0 & 0xFF, h1 >> 24 & 0xFF, h1 >> 16 & 0xFF, h1 >> 8 & 0xFF, h1 & 0xFF, h2 >> 24 & 0xFF, h2 >> 16 & 0xFF, h2 >> 8 & 0xFF, h2 & 0xFF, h3 >> 24 & 0xFF, h3 >> 16 & 0xFF, h3 >> 8 & 0xFF, h3 & 0xFF, h4 >> 24 & 0xFF, h4 >> 16 & 0xFF, h4 >> 8 & 0xFF, h4 & 0xFF, h5 >> 24 & 0xFF, h5 >> 16 & 0xFF, h5 >> 8 & 0xFF, h5 & 0xFF, h6 >> 24 & 0xFF, h6 >> 16 & 0xFF, h6 >> 8 & 0xFF, h6 & 0xFF];\n\n    if (!this.is224) {\n      arr.push(h7 >> 24 & 0xFF, h7 >> 16 & 0xFF, h7 >> 8 & 0xFF, h7 & 0xFF);\n    }\n\n    return arr;\n  };\n\n  Sha256.prototype.array = Sha256.prototype.digest;\n\n  Sha256.prototype.arrayBuffer = function () {\n    this.finalize();\n    var buffer = new ArrayBuffer(this.is224 ? 28 : 32);\n    var dataView = new DataView(buffer);\n    dataView.setUint32(0, this.h0);\n    dataView.setUint32(4, this.h1);\n    dataView.setUint32(8, this.h2);\n    dataView.setUint32(12, this.h3);\n    dataView.setUint32(16, this.h4);\n    dataView.setUint32(20, this.h5);\n    dataView.setUint32(24, this.h6);\n\n    if (!this.is224) {\n      dataView.setUint32(28, this.h7);\n    }\n\n    return buffer;\n  };\n\n  function HmacSha256(key, is224, sharedMemory) {\n    var i,\n        type = typeof key;\n\n    if (type === 'string') {\n      var bytes = [],\n          length = key.length,\n          index = 0,\n          code;\n\n      for (i = 0; i < length; ++i) {\n        code = key.charCodeAt(i);\n\n        if (code < 0x80) {\n          bytes[index++] = code;\n        } else if (code < 0x800) {\n          bytes[index++] = 0xc0 | code >> 6;\n          bytes[index++] = 0x80 | code & 0x3f;\n        } else if (code < 0xd800 || code >= 0xe000) {\n          bytes[index++] = 0xe0 | code >> 12;\n          bytes[index++] = 0x80 | code >> 6 & 0x3f;\n          bytes[index++] = 0x80 | code & 0x3f;\n        } else {\n          code = 0x10000 + ((code & 0x3ff) << 10 | key.charCodeAt(++i) & 0x3ff);\n          bytes[index++] = 0xf0 | code >> 18;\n          bytes[index++] = 0x80 | code >> 12 & 0x3f;\n          bytes[index++] = 0x80 | code >> 6 & 0x3f;\n          bytes[index++] = 0x80 | code & 0x3f;\n        }\n      }\n\n      key = bytes;\n    } else {\n      if (type === 'object') {\n        if (key === null) {\n          throw new Error(ERROR);\n        } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {\n          key = new Uint8Array(key);\n        } else if (!Array.isArray(key)) {\n          if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {\n            throw new Error(ERROR);\n          }\n        }\n      } else {\n        throw new Error(ERROR);\n      }\n    }\n\n    if (key.length > 64) {\n      key = new Sha256(is224, true).update(key).array();\n    }\n\n    var oKeyPad = [],\n        iKeyPad = [];\n\n    for (i = 0; i < 64; ++i) {\n      var b = key[i] || 0;\n      oKeyPad[i] = 0x5c ^ b;\n      iKeyPad[i] = 0x36 ^ b;\n    }\n\n    Sha256.call(this, is224, sharedMemory);\n    this.update(iKeyPad);\n    this.oKeyPad = oKeyPad;\n    this.inner = true;\n    this.sharedMemory = sharedMemory;\n  }\n\n  HmacSha256.prototype = new Sha256();\n\n  HmacSha256.prototype.finalize = function () {\n    Sha256.prototype.finalize.call(this);\n\n    if (this.inner) {\n      this.inner = false;\n      var innerHash = this.array();\n      Sha256.call(this, this.is224, this.sharedMemory);\n      this.update(this.oKeyPad);\n      this.update(innerHash);\n      Sha256.prototype.finalize.call(this);\n    }\n  };\n\n  var exports = createMethod();\n  exports.sha256 = exports;\n  exports.sha224 = createMethod(true);\n  exports.sha256.hmac = createHmacMethod();\n  exports.sha224.hmac = createHmacMethod(true);\n  return exports;\n}\n\nvar sha256 = factory();\n/**\r\n * Abstraction for crypto algorithms\r\n */\n\nvar HashHandler = /*#__PURE__*/_createClass(function HashHandler() {\n  _classCallCheck(this, HashHandler);\n});\n\nfunction decodeUTF8(s) {\n  if (typeof s !== 'string') throw new TypeError('expected string');\n  var i,\n      d = s,\n      b = new Uint8Array(d.length);\n\n  for (i = 0; i < d.length; i++) {\n    b[i] = d.charCodeAt(i);\n  }\n\n  return b;\n}\n\nfunction encodeUTF8(arr) {\n  var i,\n      s = [];\n\n  for (i = 0; i < arr.length; i++) {\n    s.push(String.fromCharCode(arr[i]));\n  }\n\n  return s.join('');\n}\n\nvar DefaultHashHandler = /*#__PURE__*/(function () {\n  var DefaultHashHandler = /*#__PURE__*/function () {\n    function DefaultHashHandler() {\n      _classCallCheck(this, DefaultHashHandler);\n    }\n\n    _createClass(DefaultHashHandler, [{\n      key: \"calcHash\",\n      value: function calcHash(valueToHash, algorithm) {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n          var candHash;\n          return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  // const encoder = new TextEncoder();\n                  // const hashArray = await window.crypto.subtle.digest(algorithm, data);\n                  // const data = encoder.encode(valueToHash);\n                  // const fhash = fsha256(valueToHash);\n                  candHash = encodeUTF8(fsha256(decodeUTF8(valueToHash))); // const hashArray = (sha256 as any).array(valueToHash);\n                  // // const hashString = this.toHashString(hashArray);\n                  // const hashString = this.toHashString2(hashArray);\n                  // console.debug('hash orig - cand', candHash, hashString);\n                  // alert(1);\n\n                  return _context2.abrupt(\"return\", candHash);\n\n                case 2:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n      }\n    }, {\n      key: \"toHashString2\",\n      value: function toHashString2(byteArray) {\n        var result = '';\n\n        var _iterator = _createForOfIteratorHelper(byteArray),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var e = _step.value;\n            result += String.fromCharCode(e);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        return result;\n      }\n    }, {\n      key: \"toHashString\",\n      value: function toHashString(buffer) {\n        var byteArray = new Uint8Array(buffer);\n        var result = '';\n\n        var _iterator2 = _createForOfIteratorHelper(byteArray),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var e = _step2.value;\n            result += String.fromCharCode(e);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        return result;\n      }\n    }]);\n\n    return DefaultHashHandler;\n  }();\n\n  DefaultHashHandler.ɵfac = function DefaultHashHandler_Factory(t) {\n    return new (t || DefaultHashHandler)();\n  };\n\n  DefaultHashHandler.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultHashHandler,\n    factory: DefaultHashHandler.ɵfac\n  });\n  return DefaultHashHandler;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * Service for logging in and logging out with\r\n * OIDC and OAuth2. Supports implicit flow and\r\n * password flow.\r\n */\n\n\nvar OAuthService = /*#__PURE__*/(function () {\n  var OAuthService = /*#__PURE__*/function (_AuthConfig) {\n    _inherits(OAuthService, _AuthConfig);\n\n    var _super5 = _createSuper(OAuthService);\n\n    function OAuthService(ngZone, http, storage, tokenValidationHandler, config, urlHelper, logger, crypto, document, dateTimeService) {\n      var _this4;\n\n      _classCallCheck(this, OAuthService);\n\n      var _a;\n\n      _this4 = _super5.call(this);\n      _this4.ngZone = ngZone;\n      _this4.http = http;\n      _this4.config = config;\n      _this4.urlHelper = urlHelper;\n      _this4.logger = logger;\n      _this4.crypto = crypto;\n      _this4.dateTimeService = dateTimeService;\n      /**\r\n       * @internal\r\n       * Deprecated:  use property events instead\r\n       */\n\n      _this4.discoveryDocumentLoaded = false;\n      /**\r\n       * The received (passed around) state, when logging\r\n       * in with implicit flow.\r\n       */\n\n      _this4.state = '';\n      _this4.eventsSubject = new Subject();\n      _this4.discoveryDocumentLoadedSubject = new Subject();\n      _this4.grantTypesSupported = [];\n      _this4.inImplicitFlow = false;\n      _this4.saveNoncesInLocalStorage = false;\n\n      _this4.debug('angular-oauth2-oidc v10'); // See https://github.com/manfredsteyer/angular-oauth2-oidc/issues/773 for why this is needed\n\n\n      _this4.document = document;\n\n      if (!config) {\n        config = {};\n      }\n\n      _this4.discoveryDocumentLoaded$ = _this4.discoveryDocumentLoadedSubject.asObservable();\n      _this4.events = _this4.eventsSubject.asObservable();\n\n      if (tokenValidationHandler) {\n        _this4.tokenValidationHandler = tokenValidationHandler;\n      }\n\n      if (config) {\n        _this4.configure(config);\n      }\n\n      try {\n        if (storage) {\n          _this4.setStorage(storage);\n        } else if (typeof sessionStorage !== 'undefined') {\n          _this4.setStorage(sessionStorage);\n        }\n      } catch (e) {\n        console.error('No OAuthStorage provided and cannot access default (sessionStorage).' + 'Consider providing a custom OAuthStorage implementation in your module.', e);\n      } // in IE, sessionStorage does not always survive a redirect\n\n\n      if (_this4.checkLocalStorageAccessable()) {\n        var ua = (_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent;\n        var msie = (ua === null || ua === void 0 ? void 0 : ua.includes('MSIE ')) || (ua === null || ua === void 0 ? void 0 : ua.includes('Trident'));\n\n        if (msie) {\n          _this4.saveNoncesInLocalStorage = true;\n        }\n      }\n\n      _this4.setupRefreshTimer();\n\n      return _this4;\n    }\n\n    _createClass(OAuthService, [{\n      key: \"checkLocalStorageAccessable\",\n      value: function checkLocalStorageAccessable() {\n        if (typeof window === 'undefined') return false;\n        var test = 'test';\n\n        try {\n          if (typeof window['localStorage'] === 'undefined') return false;\n          localStorage.setItem(test, test);\n          localStorage.removeItem(test);\n          return true;\n        } catch (e) {\n          return false;\n        }\n      }\n      /**\r\n       * Use this method to configure the service\r\n       * @param config the configuration\r\n       */\n\n    }, {\n      key: \"configure\",\n      value: function configure(config) {\n        // For the sake of downward compatibility with\n        // original configuration API\n        Object.assign(this, new AuthConfig(), config);\n        this.config = Object.assign({}, new AuthConfig(), config);\n\n        if (this.sessionChecksEnabled) {\n          this.setupSessionCheck();\n        }\n\n        this.configChanged();\n      }\n    }, {\n      key: \"configChanged\",\n      value: function configChanged() {\n        this.setupRefreshTimer();\n      }\n    }, {\n      key: \"restartSessionChecksIfStillLoggedIn\",\n      value: function restartSessionChecksIfStillLoggedIn() {\n        if (this.hasValidIdToken()) {\n          this.initSessionCheck();\n        }\n      }\n    }, {\n      key: \"restartRefreshTimerIfStillLoggedIn\",\n      value: function restartRefreshTimerIfStillLoggedIn() {\n        this.setupExpirationTimers();\n      }\n    }, {\n      key: \"setupSessionCheck\",\n      value: function setupSessionCheck() {\n        var _this5 = this;\n\n        this.events.pipe(filter(function (e) {\n          return e.type === 'token_received';\n        })).subscribe(function (e) {\n          _this5.initSessionCheck();\n        });\n      }\n      /**\r\n       * Will setup up silent refreshing for when the token is\r\n       * about to expire. When the user is logged out via this.logOut method, the\r\n       * silent refreshing will pause and not refresh the tokens until the user is\r\n       * logged back in via receiving a new token.\r\n       * @param params Additional parameter to pass\r\n       * @param listenTo Setup automatic refresh of a specific token type\r\n       */\n\n    }, {\n      key: \"setupAutomaticSilentRefresh\",\n      value: function setupAutomaticSilentRefresh() {\n        var _this6 = this;\n\n        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var listenTo = arguments.length > 1 ? arguments[1] : undefined;\n        var noPrompt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        var shouldRunSilentRefresh = true;\n        this.clearAutomaticRefreshTimer();\n        this.automaticRefreshSubscription = this.events.pipe(tap(function (e) {\n          if (e.type === 'token_received') {\n            shouldRunSilentRefresh = true;\n          } else if (e.type === 'logout') {\n            shouldRunSilentRefresh = false;\n          }\n        }), filter(function (e) {\n          return e.type === 'token_expires' && (listenTo == null || listenTo === 'any' || e.info === listenTo);\n        }), debounceTime(1000)).subscribe(function (_) {\n          if (shouldRunSilentRefresh) {\n            // this.silentRefresh(params, noPrompt).catch(_ => {\n            _this6.refreshInternal(params, noPrompt).catch(function (_) {\n              _this6.debug('Automatic silent refresh did not work');\n            });\n          }\n        });\n        this.restartRefreshTimerIfStillLoggedIn();\n      }\n    }, {\n      key: \"refreshInternal\",\n      value: function refreshInternal(params, noPrompt) {\n        if (!this.useSilentRefresh && this.responseType === 'code') {\n          return this.refreshToken();\n        } else {\n          return this.silentRefresh(params, noPrompt);\n        }\n      }\n      /**\r\n       * Convenience method that first calls `loadDiscoveryDocument(...)` and\r\n       * directly chains using the `then(...)` part of the promise to call\r\n       * the `tryLogin(...)` method.\r\n       *\r\n       * @param options LoginOptions to pass through to `tryLogin(...)`\r\n       */\n\n    }, {\n      key: \"loadDiscoveryDocumentAndTryLogin\",\n      value: function loadDiscoveryDocumentAndTryLogin() {\n        var _this7 = this;\n\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        return this.loadDiscoveryDocument().then(function (doc) {\n          return _this7.tryLogin(options);\n        });\n      }\n      /**\r\n       * Convenience method that first calls `loadDiscoveryDocumentAndTryLogin(...)`\r\n       * and if then chains to `initLoginFlow()`, but only if there is no valid\r\n       * IdToken or no valid AccessToken.\r\n       *\r\n       * @param options LoginOptions to pass through to `tryLogin(...)`\r\n       */\n\n    }, {\n      key: \"loadDiscoveryDocumentAndLogin\",\n      value: function loadDiscoveryDocumentAndLogin() {\n        var _this8 = this;\n\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        options = options || {};\n        return this.loadDiscoveryDocumentAndTryLogin(options).then(function (_) {\n          if (!_this8.hasValidIdToken() || !_this8.hasValidAccessToken()) {\n            var state = typeof options.state === 'string' ? options.state : '';\n\n            _this8.initLoginFlow(state);\n\n            return false;\n          } else {\n            return true;\n          }\n        });\n      }\n    }, {\n      key: \"debug\",\n      value: function debug() {\n        if (this.showDebugInformation) {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          this.logger.debug.apply(this.logger, args);\n        }\n      }\n    }, {\n      key: \"validateUrlFromDiscoveryDocument\",\n      value: function validateUrlFromDiscoveryDocument(url) {\n        var errors = [];\n        var httpsCheck = this.validateUrlForHttps(url);\n        var issuerCheck = this.validateUrlAgainstIssuer(url);\n\n        if (!httpsCheck) {\n          errors.push('https for all urls required. Also for urls received by discovery.');\n        }\n\n        if (!issuerCheck) {\n          errors.push('Every url in discovery document has to start with the issuer url.' + 'Also see property strictDiscoveryDocumentValidation.');\n        }\n\n        return errors;\n      }\n    }, {\n      key: \"validateUrlForHttps\",\n      value: function validateUrlForHttps(url) {\n        if (!url) {\n          return true;\n        }\n\n        var lcUrl = url.toLowerCase();\n\n        if (this.requireHttps === false) {\n          return true;\n        }\n\n        if ((lcUrl.match(/^http:\\/\\/localhost($|[:\\/])/) || lcUrl.match(/^http:\\/\\/localhost($|[:\\/])/)) && this.requireHttps === 'remoteOnly') {\n          return true;\n        }\n\n        return lcUrl.startsWith('https://');\n      }\n    }, {\n      key: \"assertUrlNotNullAndCorrectProtocol\",\n      value: function assertUrlNotNullAndCorrectProtocol(url, description) {\n        if (!url) {\n          throw new Error(\"'\".concat(description, \"' should not be null\"));\n        }\n\n        if (!this.validateUrlForHttps(url)) {\n          throw new Error(\"'\".concat(description, \"' must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\"));\n        }\n      }\n    }, {\n      key: \"validateUrlAgainstIssuer\",\n      value: function validateUrlAgainstIssuer(url) {\n        if (!this.strictDiscoveryDocumentValidation) {\n          return true;\n        }\n\n        if (!url) {\n          return true;\n        }\n\n        return url.toLowerCase().startsWith(this.issuer.toLowerCase());\n      }\n    }, {\n      key: \"setupRefreshTimer\",\n      value: function setupRefreshTimer() {\n        var _this9 = this;\n\n        if (typeof window === 'undefined') {\n          this.debug('timer not supported on this plattform');\n          return;\n        }\n\n        if (this.hasValidIdToken() || this.hasValidAccessToken()) {\n          this.clearAccessTokenTimer();\n          this.clearIdTokenTimer();\n          this.setupExpirationTimers();\n        }\n\n        if (this.tokenReceivedSubscription) this.tokenReceivedSubscription.unsubscribe();\n        this.tokenReceivedSubscription = this.events.pipe(filter(function (e) {\n          return e.type === 'token_received';\n        })).subscribe(function (_) {\n          _this9.clearAccessTokenTimer();\n\n          _this9.clearIdTokenTimer();\n\n          _this9.setupExpirationTimers();\n        });\n      }\n    }, {\n      key: \"setupExpirationTimers\",\n      value: function setupExpirationTimers() {\n        if (this.hasValidAccessToken()) {\n          this.setupAccessTokenTimer();\n        }\n\n        if (this.hasValidIdToken()) {\n          this.setupIdTokenTimer();\n        }\n      }\n    }, {\n      key: \"setupAccessTokenTimer\",\n      value: function setupAccessTokenTimer() {\n        var _this10 = this;\n\n        var expiration = this.getAccessTokenExpiration();\n        var storedAt = this.getAccessTokenStoredAt();\n        var timeout = this.calcTimeout(storedAt, expiration);\n        this.ngZone.runOutsideAngular(function () {\n          _this10.accessTokenTimeoutSubscription = of(new OAuthInfoEvent('token_expires', 'access_token')).pipe(delay(timeout)).subscribe(function (e) {\n            _this10.ngZone.run(function () {\n              _this10.eventsSubject.next(e);\n            });\n          });\n        });\n      }\n    }, {\n      key: \"setupIdTokenTimer\",\n      value: function setupIdTokenTimer() {\n        var _this11 = this;\n\n        var expiration = this.getIdTokenExpiration();\n        var storedAt = this.getIdTokenStoredAt();\n        var timeout = this.calcTimeout(storedAt, expiration);\n        this.ngZone.runOutsideAngular(function () {\n          _this11.idTokenTimeoutSubscription = of(new OAuthInfoEvent('token_expires', 'id_token')).pipe(delay(timeout)).subscribe(function (e) {\n            _this11.ngZone.run(function () {\n              _this11.eventsSubject.next(e);\n            });\n          });\n        });\n      }\n      /**\r\n       * Stops timers for automatic refresh.\r\n       * To restart it, call setupAutomaticSilentRefresh again.\r\n       */\n\n    }, {\n      key: \"stopAutomaticRefresh\",\n      value: function stopAutomaticRefresh() {\n        this.clearAccessTokenTimer();\n        this.clearIdTokenTimer();\n        this.clearAutomaticRefreshTimer();\n      }\n    }, {\n      key: \"clearAccessTokenTimer\",\n      value: function clearAccessTokenTimer() {\n        if (this.accessTokenTimeoutSubscription) {\n          this.accessTokenTimeoutSubscription.unsubscribe();\n        }\n      }\n    }, {\n      key: \"clearIdTokenTimer\",\n      value: function clearIdTokenTimer() {\n        if (this.idTokenTimeoutSubscription) {\n          this.idTokenTimeoutSubscription.unsubscribe();\n        }\n      }\n    }, {\n      key: \"clearAutomaticRefreshTimer\",\n      value: function clearAutomaticRefreshTimer() {\n        if (this.automaticRefreshSubscription) {\n          this.automaticRefreshSubscription.unsubscribe();\n        }\n      }\n    }, {\n      key: \"calcTimeout\",\n      value: function calcTimeout(storedAt, expiration) {\n        var now = this.dateTimeService.now();\n        var delta = (expiration - storedAt) * this.timeoutFactor - (now - storedAt);\n        return Math.max(0, delta);\n      }\n      /**\r\n       * DEPRECATED. Use a provider for OAuthStorage instead:\r\n       *\r\n       * { provide: OAuthStorage, useFactory: oAuthStorageFactory }\r\n       * export function oAuthStorageFactory(): OAuthStorage { return localStorage; }\r\n       * Sets a custom storage used to store the received\r\n       * tokens on client side. By default, the browser's\r\n       * sessionStorage is used.\r\n       * @ignore\r\n       *\r\n       * @param storage\r\n       */\n\n    }, {\n      key: \"setStorage\",\n      value: function setStorage(storage) {\n        this._storage = storage;\n        this.configChanged();\n      }\n      /**\r\n       * Loads the discovery document to configure most\r\n       * properties of this service. The url of the discovery\r\n       * document is infered from the issuer's url according\r\n       * to the OpenId Connect spec. To use another url you\r\n       * can pass it to to optional parameter fullUrl.\r\n       *\r\n       * @param fullUrl\r\n       */\n\n    }, {\n      key: \"loadDiscoveryDocument\",\n      value: function loadDiscoveryDocument() {\n        var _this12 = this;\n\n        var fullUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        return new Promise(function (resolve, reject) {\n          if (!fullUrl) {\n            fullUrl = _this12.issuer || '';\n\n            if (!fullUrl.endsWith('/')) {\n              fullUrl += '/';\n            }\n\n            fullUrl += '.well-known/openid-configuration';\n          }\n\n          if (!_this12.validateUrlForHttps(fullUrl)) {\n            reject(\"issuer  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n            return;\n          }\n\n          _this12.http.get(fullUrl).subscribe(function (doc) {\n            if (!_this12.validateDiscoveryDocument(doc)) {\n              _this12.eventsSubject.next(new OAuthErrorEvent('discovery_document_validation_error', null));\n\n              reject('discovery_document_validation_error');\n              return;\n            }\n\n            _this12.loginUrl = doc.authorization_endpoint;\n            _this12.logoutUrl = doc.end_session_endpoint || _this12.logoutUrl;\n            _this12.grantTypesSupported = doc.grant_types_supported;\n            _this12.issuer = doc.issuer;\n            _this12.tokenEndpoint = doc.token_endpoint;\n            _this12.userinfoEndpoint = doc.userinfo_endpoint || _this12.userinfoEndpoint;\n            _this12.jwksUri = doc.jwks_uri;\n            _this12.sessionCheckIFrameUrl = doc.check_session_iframe || _this12.sessionCheckIFrameUrl;\n            _this12.discoveryDocumentLoaded = true;\n\n            _this12.discoveryDocumentLoadedSubject.next(doc);\n\n            _this12.revocationEndpoint = doc.revocation_endpoint || _this12.revocationEndpoint;\n\n            if (_this12.sessionChecksEnabled) {\n              _this12.restartSessionChecksIfStillLoggedIn();\n            }\n\n            _this12.loadJwks().then(function (jwks) {\n              var result = {\n                discoveryDocument: doc,\n                jwks: jwks\n              };\n              var event = new OAuthSuccessEvent('discovery_document_loaded', result);\n\n              _this12.eventsSubject.next(event);\n\n              resolve(event);\n              return;\n            }).catch(function (err) {\n              _this12.eventsSubject.next(new OAuthErrorEvent('discovery_document_load_error', err));\n\n              reject(err);\n              return;\n            });\n          }, function (err) {\n            _this12.logger.error('error loading discovery document', err);\n\n            _this12.eventsSubject.next(new OAuthErrorEvent('discovery_document_load_error', err));\n\n            reject(err);\n          });\n        });\n      }\n    }, {\n      key: \"loadJwks\",\n      value: function loadJwks() {\n        var _this13 = this;\n\n        return new Promise(function (resolve, reject) {\n          if (_this13.jwksUri) {\n            _this13.http.get(_this13.jwksUri).subscribe(function (jwks) {\n              _this13.jwks = jwks;\n\n              _this13.eventsSubject.next(new OAuthSuccessEvent('discovery_document_loaded'));\n\n              resolve(jwks);\n            }, function (err) {\n              _this13.logger.error('error loading jwks', err);\n\n              _this13.eventsSubject.next(new OAuthErrorEvent('jwks_load_error', err));\n\n              reject(err);\n            });\n          } else {\n            resolve(null);\n          }\n        });\n      }\n    }, {\n      key: \"validateDiscoveryDocument\",\n      value: function validateDiscoveryDocument(doc) {\n        var errors;\n\n        if (!this.skipIssuerCheck && doc.issuer !== this.issuer) {\n          this.logger.error('invalid issuer in discovery document', 'expected: ' + this.issuer, 'current: ' + doc.issuer);\n          return false;\n        }\n\n        errors = this.validateUrlFromDiscoveryDocument(doc.authorization_endpoint);\n\n        if (errors.length > 0) {\n          this.logger.error('error validating authorization_endpoint in discovery document', errors);\n          return false;\n        }\n\n        errors = this.validateUrlFromDiscoveryDocument(doc.end_session_endpoint);\n\n        if (errors.length > 0) {\n          this.logger.error('error validating end_session_endpoint in discovery document', errors);\n          return false;\n        }\n\n        errors = this.validateUrlFromDiscoveryDocument(doc.token_endpoint);\n\n        if (errors.length > 0) {\n          this.logger.error('error validating token_endpoint in discovery document', errors);\n        }\n\n        errors = this.validateUrlFromDiscoveryDocument(doc.revocation_endpoint);\n\n        if (errors.length > 0) {\n          this.logger.error('error validating revocation_endpoint in discovery document', errors);\n        }\n\n        errors = this.validateUrlFromDiscoveryDocument(doc.userinfo_endpoint);\n\n        if (errors.length > 0) {\n          this.logger.error('error validating userinfo_endpoint in discovery document', errors);\n          return false;\n        }\n\n        errors = this.validateUrlFromDiscoveryDocument(doc.jwks_uri);\n\n        if (errors.length > 0) {\n          this.logger.error('error validating jwks_uri in discovery document', errors);\n          return false;\n        }\n\n        if (this.sessionChecksEnabled && !doc.check_session_iframe) {\n          this.logger.warn('sessionChecksEnabled is activated but discovery document' + ' does not contain a check_session_iframe field');\n        }\n\n        return true;\n      }\n      /**\r\n       * Uses password flow to exchange userName and password for an\r\n       * access_token. After receiving the access_token, this method\r\n       * uses it to query the userinfo endpoint in order to get information\r\n       * about the user in question.\r\n       *\r\n       * When using this, make sure that the property oidc is set to false.\r\n       * Otherwise stricter validations take place that make this operation\r\n       * fail.\r\n       *\r\n       * @param userName\r\n       * @param password\r\n       * @param headers Optional additional http-headers.\r\n       */\n\n    }, {\n      key: \"fetchTokenUsingPasswordFlowAndLoadUserProfile\",\n      value: function fetchTokenUsingPasswordFlowAndLoadUserProfile(userName, password) {\n        var _this14 = this;\n\n        var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new HttpHeaders();\n        return this.fetchTokenUsingPasswordFlow(userName, password, headers).then(function () {\n          return _this14.loadUserProfile();\n        });\n      }\n      /**\r\n       * Loads the user profile by accessing the user info endpoint defined by OpenId Connect.\r\n       *\r\n       * When using this with OAuth2 password flow, make sure that the property oidc is set to false.\r\n       * Otherwise stricter validations take place that make this operation fail.\r\n       */\n\n    }, {\n      key: \"loadUserProfile\",\n      value: function loadUserProfile() {\n        var _this15 = this;\n\n        if (!this.hasValidAccessToken()) {\n          throw new Error('Can not load User Profile without access_token');\n        }\n\n        if (!this.validateUrlForHttps(this.userinfoEndpoint)) {\n          throw new Error(\"userinfoEndpoint must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n        }\n\n        return new Promise(function (resolve, reject) {\n          var headers = new HttpHeaders().set('Authorization', 'Bearer ' + _this15.getAccessToken());\n\n          _this15.http.get(_this15.userinfoEndpoint, {\n            headers: headers,\n            observe: 'response',\n            responseType: 'text'\n          }).subscribe(function (response) {\n            _this15.debug('userinfo received', JSON.stringify(response));\n\n            if (response.headers.get('content-type').startsWith('application/json')) {\n              var info = JSON.parse(response.body);\n              var existingClaims = _this15.getIdentityClaims() || {};\n\n              if (!_this15.skipSubjectCheck) {\n                if (_this15.oidc && (!existingClaims['sub'] || info.sub !== existingClaims['sub'])) {\n                  var _err = 'if property oidc is true, the received user-id (sub) has to be the user-id ' + 'of the user that has logged in with oidc.\\n' + 'if you are not using oidc but just oauth2 password flow set oidc to false';\n\n                  reject(_err);\n                  return;\n                }\n              }\n\n              info = Object.assign({}, existingClaims, info);\n\n              _this15._storage.setItem('id_token_claims_obj', JSON.stringify(info));\n\n              _this15.eventsSubject.next(new OAuthSuccessEvent('user_profile_loaded'));\n\n              resolve({\n                info: info\n              });\n            } else {\n              _this15.debug('userinfo is not JSON, treating it as JWE/JWS');\n\n              _this15.eventsSubject.next(new OAuthSuccessEvent('user_profile_loaded'));\n\n              resolve(JSON.parse(response.body));\n            }\n          }, function (err) {\n            _this15.logger.error('error loading user info', err);\n\n            _this15.eventsSubject.next(new OAuthErrorEvent('user_profile_load_error', err));\n\n            reject(err);\n          });\n        });\n      }\n      /**\r\n       * Uses password flow to exchange userName and password for an access_token.\r\n       * @param userName\r\n       * @param password\r\n       * @param headers Optional additional http-headers.\r\n       */\n\n    }, {\n      key: \"fetchTokenUsingPasswordFlow\",\n      value: function fetchTokenUsingPasswordFlow(userName, password) {\n        var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new HttpHeaders();\n        var parameters = {\n          username: userName,\n          password: password\n        };\n        return this.fetchTokenUsingGrant('password', parameters, headers);\n      }\n      /**\r\n       * Uses a custom grant type to retrieve tokens.\r\n       * @param grantType Grant type.\r\n       * @param parameters Parameters to pass.\r\n       * @param headers Optional additional HTTP headers.\r\n       */\n\n    }, {\n      key: \"fetchTokenUsingGrant\",\n      value: function fetchTokenUsingGrant(grantType, parameters) {\n        var _this16 = this;\n\n        var headers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new HttpHeaders();\n        this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint, 'tokenEndpoint');\n        /**\r\n         * A `HttpParameterCodec` that uses `encodeURIComponent` and `decodeURIComponent` to\r\n         * serialize and parse URL parameter keys and values.\r\n         *\r\n         * @stable\r\n         */\n\n        var params = new HttpParams({\n          encoder: new WebHttpUrlEncodingCodec()\n        }).set('grant_type', grantType).set('scope', this.scope);\n\n        if (this.useHttpBasicAuth) {\n          var header = btoa(\"\".concat(this.clientId, \":\").concat(this.dummyClientSecret));\n          headers = headers.set('Authorization', 'Basic ' + header);\n        }\n\n        if (!this.useHttpBasicAuth) {\n          params = params.set('client_id', this.clientId);\n        }\n\n        if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n          params = params.set('client_secret', this.dummyClientSecret);\n        }\n\n        if (this.customQueryParams) {\n          var _iterator3 = _createForOfIteratorHelper(Object.getOwnPropertyNames(this.customQueryParams)),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var key = _step3.value;\n              params = params.set(key, this.customQueryParams[key]);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        } // set explicit parameters last, to allow overwriting\n\n\n        for (var _i = 0, _Object$keys = Object.keys(parameters); _i < _Object$keys.length; _i++) {\n          var _key2 = _Object$keys[_i];\n          params = params.set(_key2, parameters[_key2]);\n        }\n\n        headers = headers.set('Content-Type', 'application/x-www-form-urlencoded');\n        return new Promise(function (resolve, reject) {\n          _this16.http.post(_this16.tokenEndpoint, params, {\n            headers: headers\n          }).subscribe(function (tokenResponse) {\n            _this16.debug('tokenResponse', tokenResponse);\n\n            _this16.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in || _this16.fallbackAccessTokenExpirationTimeInSec, tokenResponse.scope, _this16.extractRecognizedCustomParameters(tokenResponse));\n\n            if (_this16.oidc && tokenResponse.id_token) {\n              _this16.processIdToken(tokenResponse.id_token, tokenResponse.access_token).then(function (result) {\n                _this16.storeIdToken(result);\n\n                resolve(tokenResponse);\n              });\n            }\n\n            _this16.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n\n            resolve(tokenResponse);\n          }, function (err) {\n            _this16.logger.error('Error performing ${grantType} flow', err);\n\n            _this16.eventsSubject.next(new OAuthErrorEvent('token_error', err));\n\n            reject(err);\n          });\n        });\n      }\n      /**\r\n       * Refreshes the token using a refresh_token.\r\n       * This does not work for implicit flow, b/c\r\n       * there is no refresh_token in this flow.\r\n       * A solution for this is provided by the\r\n       * method silentRefresh.\r\n       */\n\n    }, {\n      key: \"refreshToken\",\n      value: function refreshToken() {\n        var _this17 = this;\n\n        this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint, 'tokenEndpoint');\n        return new Promise(function (resolve, reject) {\n          var params = new HttpParams({\n            encoder: new WebHttpUrlEncodingCodec()\n          }).set('grant_type', 'refresh_token').set('scope', _this17.scope).set('refresh_token', _this17._storage.getItem('refresh_token'));\n          var headers = new HttpHeaders().set('Content-Type', 'application/x-www-form-urlencoded');\n\n          if (_this17.useHttpBasicAuth) {\n            var header = btoa(\"\".concat(_this17.clientId, \":\").concat(_this17.dummyClientSecret));\n            headers = headers.set('Authorization', 'Basic ' + header);\n          }\n\n          if (!_this17.useHttpBasicAuth) {\n            params = params.set('client_id', _this17.clientId);\n          }\n\n          if (!_this17.useHttpBasicAuth && _this17.dummyClientSecret) {\n            params = params.set('client_secret', _this17.dummyClientSecret);\n          }\n\n          if (_this17.customQueryParams) {\n            var _iterator4 = _createForOfIteratorHelper(Object.getOwnPropertyNames(_this17.customQueryParams)),\n                _step4;\n\n            try {\n              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                var key = _step4.value;\n                params = params.set(key, _this17.customQueryParams[key]);\n              }\n            } catch (err) {\n              _iterator4.e(err);\n            } finally {\n              _iterator4.f();\n            }\n          }\n\n          _this17.http.post(_this17.tokenEndpoint, params, {\n            headers: headers\n          }).pipe(switchMap(function (tokenResponse) {\n            if (tokenResponse.id_token) {\n              return from(_this17.processIdToken(tokenResponse.id_token, tokenResponse.access_token, true)).pipe(tap(function (result) {\n                return _this17.storeIdToken(result);\n              }), map(function (_) {\n                return tokenResponse;\n              }));\n            } else {\n              return of(tokenResponse);\n            }\n          })).subscribe(function (tokenResponse) {\n            _this17.debug('refresh tokenResponse', tokenResponse);\n\n            _this17.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in || _this17.fallbackAccessTokenExpirationTimeInSec, tokenResponse.scope, _this17.extractRecognizedCustomParameters(tokenResponse));\n\n            _this17.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n\n            _this17.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n\n            resolve(tokenResponse);\n          }, function (err) {\n            _this17.logger.error('Error refreshing token', err);\n\n            _this17.eventsSubject.next(new OAuthErrorEvent('token_refresh_error', err));\n\n            reject(err);\n          });\n        });\n      }\n    }, {\n      key: \"removeSilentRefreshEventListener\",\n      value: function removeSilentRefreshEventListener() {\n        if (this.silentRefreshPostMessageEventListener) {\n          window.removeEventListener('message', this.silentRefreshPostMessageEventListener);\n          this.silentRefreshPostMessageEventListener = null;\n        }\n      }\n    }, {\n      key: \"setupSilentRefreshEventListener\",\n      value: function setupSilentRefreshEventListener() {\n        var _this18 = this;\n\n        this.removeSilentRefreshEventListener();\n\n        this.silentRefreshPostMessageEventListener = function (e) {\n          var message = _this18.processMessageEventMessage(e);\n\n          _this18.tryLogin({\n            customHashFragment: message,\n            preventClearHashAfterLogin: true,\n            customRedirectUri: _this18.silentRefreshRedirectUri || _this18.redirectUri\n          }).catch(function (err) {\n            return _this18.debug('tryLogin during silent refresh failed', err);\n          });\n        };\n\n        window.addEventListener('message', this.silentRefreshPostMessageEventListener);\n      }\n      /**\r\n       * Performs a silent refresh for implicit flow.\r\n       * Use this method to get new tokens when/before\r\n       * the existing tokens expire.\r\n       */\n\n    }, {\n      key: \"silentRefresh\",\n      value: function silentRefresh() {\n        var _this19 = this;\n\n        var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var noPrompt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var claims = this.getIdentityClaims() || {};\n\n        if (this.useIdTokenHintForSilentRefresh && this.hasValidIdToken()) {\n          params['id_token_hint'] = this.getIdToken();\n        }\n\n        if (!this.validateUrlForHttps(this.loginUrl)) {\n          throw new Error(\"loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n        }\n\n        if (typeof this.document === 'undefined') {\n          throw new Error('silent refresh is not supported on this platform');\n        }\n\n        var existingIframe = this.document.getElementById(this.silentRefreshIFrameName);\n\n        if (existingIframe) {\n          this.document.body.removeChild(existingIframe);\n        }\n\n        this.silentRefreshSubject = claims['sub'];\n        var iframe = this.document.createElement('iframe');\n        iframe.id = this.silentRefreshIFrameName;\n        this.setupSilentRefreshEventListener();\n        var redirectUri = this.silentRefreshRedirectUri || this.redirectUri;\n        this.createLoginUrl(null, null, redirectUri, noPrompt, params).then(function (url) {\n          iframe.setAttribute('src', url);\n\n          if (!_this19.silentRefreshShowIFrame) {\n            iframe.style['display'] = 'none';\n          }\n\n          _this19.document.body.appendChild(iframe);\n        });\n        var errors = this.events.pipe(filter(function (e) {\n          return e instanceof OAuthErrorEvent;\n        }), first());\n        var success = this.events.pipe(filter(function (e) {\n          return e.type === 'token_received';\n        }), first());\n        var timeout = of(new OAuthErrorEvent('silent_refresh_timeout', null)).pipe(delay(this.silentRefreshTimeout));\n        return race([errors, success, timeout]).pipe(map(function (e) {\n          if (e instanceof OAuthErrorEvent) {\n            if (e.type === 'silent_refresh_timeout') {\n              _this19.eventsSubject.next(e);\n            } else {\n              e = new OAuthErrorEvent('silent_refresh_error', e);\n\n              _this19.eventsSubject.next(e);\n            }\n\n            throw e;\n          } else if (e.type === 'token_received') {\n            e = new OAuthSuccessEvent('silently_refreshed');\n\n            _this19.eventsSubject.next(e);\n          }\n\n          return e;\n        })).toPromise();\n      }\n      /**\r\n       * This method exists for backwards compatibility.\r\n       * {@link OAuthService#initLoginFlowInPopup} handles both code\r\n       * and implicit flows.\r\n       */\n\n    }, {\n      key: \"initImplicitFlowInPopup\",\n      value: function initImplicitFlowInPopup(options) {\n        return this.initLoginFlowInPopup(options);\n      }\n    }, {\n      key: \"initLoginFlowInPopup\",\n      value: function initLoginFlowInPopup(options) {\n        var _this20 = this;\n\n        options = options || {};\n        return this.createLoginUrl(null, null, this.silentRefreshRedirectUri, false, {\n          display: 'popup'\n        }).then(function (url) {\n          return new Promise(function (resolve, reject) {\n            /**\r\n             * Error handling section\r\n             */\n            var checkForPopupClosedInterval = 500;\n            var windowRef = null; // If we got no window reference we open a window\n            // else we are using the window already opened\n\n            if (!options.windowRef) {\n              windowRef = window.open(url, 'ngx-oauth2-oidc-login', _this20.calculatePopupFeatures(options));\n            } else if (options.windowRef && !options.windowRef.closed) {\n              windowRef = options.windowRef;\n              windowRef.location.href = url;\n            }\n\n            var checkForPopupClosedTimer;\n\n            var tryLogin = function tryLogin(hash) {\n              _this20.tryLogin({\n                customHashFragment: hash,\n                preventClearHashAfterLogin: true,\n                customRedirectUri: _this20.silentRefreshRedirectUri\n              }).then(function () {\n                cleanup();\n                resolve(true);\n              }, function (err) {\n                cleanup();\n                reject(err);\n              });\n            };\n\n            var checkForPopupClosed = function checkForPopupClosed() {\n              if (!windowRef || windowRef.closed) {\n                cleanup();\n                reject(new OAuthErrorEvent('popup_closed', {}));\n              }\n            };\n\n            if (!windowRef) {\n              reject(new OAuthErrorEvent('popup_blocked', {}));\n            } else {\n              checkForPopupClosedTimer = window.setInterval(checkForPopupClosed, checkForPopupClosedInterval);\n            }\n\n            var cleanup = function cleanup() {\n              window.clearInterval(checkForPopupClosedTimer);\n              window.removeEventListener('storage', storageListener);\n              window.removeEventListener('message', listener);\n\n              if (windowRef !== null) {\n                windowRef.close();\n              }\n\n              windowRef = null;\n            };\n\n            var listener = function listener(e) {\n              var message = _this20.processMessageEventMessage(e);\n\n              if (message && message !== null) {\n                window.removeEventListener('storage', storageListener);\n                tryLogin(message);\n              } else {\n                console.log('false event firing');\n              }\n            };\n\n            var storageListener = function storageListener(event) {\n              if (event.key === 'auth_hash') {\n                window.removeEventListener('message', listener);\n                tryLogin(event.newValue);\n              }\n            };\n\n            window.addEventListener('message', listener);\n            window.addEventListener('storage', storageListener);\n          });\n        });\n      }\n    }, {\n      key: \"calculatePopupFeatures\",\n      value: function calculatePopupFeatures(options) {\n        // Specify an static height and width and calculate centered position\n        var height = options.height || 470;\n        var width = options.width || 500;\n        var left = window.screenLeft + (window.outerWidth - width) / 2;\n        var top = window.screenTop + (window.outerHeight - height) / 2;\n        return \"location=no,toolbar=no,width=\".concat(width, \",height=\").concat(height, \",top=\").concat(top, \",left=\").concat(left);\n      }\n    }, {\n      key: \"processMessageEventMessage\",\n      value: function processMessageEventMessage(e) {\n        var expectedPrefix = '#';\n\n        if (this.silentRefreshMessagePrefix) {\n          expectedPrefix += this.silentRefreshMessagePrefix;\n        }\n\n        if (!e || !e.data || typeof e.data !== 'string') {\n          return;\n        }\n\n        var prefixedMessage = e.data;\n\n        if (!prefixedMessage.startsWith(expectedPrefix)) {\n          return;\n        }\n\n        return '#' + prefixedMessage.substr(expectedPrefix.length);\n      }\n    }, {\n      key: \"canPerformSessionCheck\",\n      value: function canPerformSessionCheck() {\n        if (!this.sessionChecksEnabled) {\n          return false;\n        }\n\n        if (!this.sessionCheckIFrameUrl) {\n          console.warn('sessionChecksEnabled is activated but there is no sessionCheckIFrameUrl');\n          return false;\n        }\n\n        var sessionState = this.getSessionState();\n\n        if (!sessionState) {\n          console.warn('sessionChecksEnabled is activated but there is no session_state');\n          return false;\n        }\n\n        if (typeof this.document === 'undefined') {\n          return false;\n        }\n\n        return true;\n      }\n    }, {\n      key: \"setupSessionCheckEventListener\",\n      value: function setupSessionCheckEventListener() {\n        var _this21 = this;\n\n        this.removeSessionCheckEventListener();\n\n        this.sessionCheckEventListener = function (e) {\n          var origin = e.origin.toLowerCase();\n\n          var issuer = _this21.issuer.toLowerCase();\n\n          _this21.debug('sessionCheckEventListener');\n\n          if (!issuer.startsWith(origin)) {\n            _this21.debug('sessionCheckEventListener', 'wrong origin', origin, 'expected', issuer, 'event', e);\n\n            return;\n          } // only run in Angular zone if it is 'changed' or 'error'\n\n\n          switch (e.data) {\n            case 'unchanged':\n              _this21.ngZone.run(function () {\n                _this21.handleSessionUnchanged();\n              });\n\n              break;\n\n            case 'changed':\n              _this21.ngZone.run(function () {\n                _this21.handleSessionChange();\n              });\n\n              break;\n\n            case 'error':\n              _this21.ngZone.run(function () {\n                _this21.handleSessionError();\n              });\n\n              break;\n          }\n\n          _this21.debug('got info from session check inframe', e);\n        }; // prevent Angular from refreshing the view on every message (runs in intervals)\n\n\n        this.ngZone.runOutsideAngular(function () {\n          window.addEventListener('message', _this21.sessionCheckEventListener);\n        });\n      }\n    }, {\n      key: \"handleSessionUnchanged\",\n      value: function handleSessionUnchanged() {\n        this.debug('session check', 'session unchanged');\n        this.eventsSubject.next(new OAuthInfoEvent('session_unchanged'));\n      }\n    }, {\n      key: \"handleSessionChange\",\n      value: function handleSessionChange() {\n        var _this22 = this;\n\n        this.eventsSubject.next(new OAuthInfoEvent('session_changed'));\n        this.stopSessionCheckTimer();\n\n        if (!this.useSilentRefresh && this.responseType === 'code') {\n          this.refreshToken().then(function (_) {\n            _this22.debug('token refresh after session change worked');\n          }).catch(function (_) {\n            _this22.debug('token refresh did not work after session changed');\n\n            _this22.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n\n            _this22.logOut(true);\n          });\n        } else if (this.silentRefreshRedirectUri) {\n          this.silentRefresh().catch(function (_) {\n            return _this22.debug('silent refresh failed after session changed');\n          });\n          this.waitForSilentRefreshAfterSessionChange();\n        } else {\n          this.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n          this.logOut(true);\n        }\n      }\n    }, {\n      key: \"waitForSilentRefreshAfterSessionChange\",\n      value: function waitForSilentRefreshAfterSessionChange() {\n        var _this23 = this;\n\n        this.events.pipe(filter(function (e) {\n          return e.type === 'silently_refreshed' || e.type === 'silent_refresh_timeout' || e.type === 'silent_refresh_error';\n        }), first()).subscribe(function (e) {\n          if (e.type !== 'silently_refreshed') {\n            _this23.debug('silent refresh did not work after session changed');\n\n            _this23.eventsSubject.next(new OAuthInfoEvent('session_terminated'));\n\n            _this23.logOut(true);\n          }\n        });\n      }\n    }, {\n      key: \"handleSessionError\",\n      value: function handleSessionError() {\n        this.stopSessionCheckTimer();\n        this.eventsSubject.next(new OAuthInfoEvent('session_error'));\n      }\n    }, {\n      key: \"removeSessionCheckEventListener\",\n      value: function removeSessionCheckEventListener() {\n        if (this.sessionCheckEventListener) {\n          window.removeEventListener('message', this.sessionCheckEventListener);\n          this.sessionCheckEventListener = null;\n        }\n      }\n    }, {\n      key: \"initSessionCheck\",\n      value: function initSessionCheck() {\n        if (!this.canPerformSessionCheck()) {\n          return;\n        }\n\n        var existingIframe = this.document.getElementById(this.sessionCheckIFrameName);\n\n        if (existingIframe) {\n          this.document.body.removeChild(existingIframe);\n        }\n\n        var iframe = this.document.createElement('iframe');\n        iframe.id = this.sessionCheckIFrameName;\n        this.setupSessionCheckEventListener();\n        var url = this.sessionCheckIFrameUrl;\n        iframe.setAttribute('src', url);\n        iframe.style.display = 'none';\n        this.document.body.appendChild(iframe);\n        this.startSessionCheckTimer();\n      }\n    }, {\n      key: \"startSessionCheckTimer\",\n      value: function startSessionCheckTimer() {\n        var _this24 = this;\n\n        this.stopSessionCheckTimer();\n        this.ngZone.runOutsideAngular(function () {\n          _this24.sessionCheckTimer = setInterval(_this24.checkSession.bind(_this24), _this24.sessionCheckIntervall);\n        });\n      }\n    }, {\n      key: \"stopSessionCheckTimer\",\n      value: function stopSessionCheckTimer() {\n        if (this.sessionCheckTimer) {\n          clearInterval(this.sessionCheckTimer);\n          this.sessionCheckTimer = null;\n        }\n      }\n    }, {\n      key: \"checkSession\",\n      value: function checkSession() {\n        var iframe = this.document.getElementById(this.sessionCheckIFrameName);\n\n        if (!iframe) {\n          this.logger.warn('checkSession did not find iframe', this.sessionCheckIFrameName);\n        }\n\n        var sessionState = this.getSessionState();\n\n        if (!sessionState) {\n          this.stopSessionCheckTimer();\n        }\n\n        var message = this.clientId + ' ' + sessionState;\n        iframe.contentWindow.postMessage(message, this.issuer);\n      }\n    }, {\n      key: \"createLoginUrl\",\n      value: function createLoginUrl() {\n        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var loginHint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n        var customRedirectUri = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n        var noPrompt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        var params = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n          var that, redirectUri, nonce, seperationChar, scope, url, _yield$this$createCha, _yield$this$createCha2, challenge, verifier, _i2, _Object$keys2, key, _iterator5, _step5, _key3;\n\n          return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  that = this;\n\n                  if (customRedirectUri) {\n                    redirectUri = customRedirectUri;\n                  } else {\n                    redirectUri = this.redirectUri;\n                  }\n\n                  _context3.next = 4;\n                  return this.createAndSaveNonce();\n\n                case 4:\n                  nonce = _context3.sent;\n\n                  if (state) {\n                    state = nonce + this.config.nonceStateSeparator + encodeURIComponent(state);\n                  } else {\n                    state = nonce;\n                  }\n\n                  if (!(!this.requestAccessToken && !this.oidc)) {\n                    _context3.next = 8;\n                    break;\n                  }\n\n                  throw new Error('Either requestAccessToken or oidc or both must be true');\n\n                case 8:\n                  if (this.config.responseType) {\n                    this.responseType = this.config.responseType;\n                  } else {\n                    if (this.oidc && this.requestAccessToken) {\n                      this.responseType = 'id_token token';\n                    } else if (this.oidc && !this.requestAccessToken) {\n                      this.responseType = 'id_token';\n                    } else {\n                      this.responseType = 'token';\n                    }\n                  }\n\n                  seperationChar = that.loginUrl.indexOf('?') > -1 ? '&' : '?';\n                  scope = that.scope;\n\n                  if (this.oidc && !scope.match(/(^|\\s)openid($|\\s)/)) {\n                    scope = 'openid ' + scope;\n                  }\n\n                  url = that.loginUrl + seperationChar + 'response_type=' + encodeURIComponent(that.responseType) + '&client_id=' + encodeURIComponent(that.clientId) + '&state=' + encodeURIComponent(state) + '&redirect_uri=' + encodeURIComponent(redirectUri) + '&scope=' + encodeURIComponent(scope);\n\n                  if (!(this.responseType.includes('code') && !this.disablePKCE)) {\n                    _context3.next = 23;\n                    break;\n                  }\n\n                  _context3.next = 16;\n                  return this.createChallangeVerifierPairForPKCE();\n\n                case 16:\n                  _yield$this$createCha = _context3.sent;\n                  _yield$this$createCha2 = _slicedToArray(_yield$this$createCha, 2);\n                  challenge = _yield$this$createCha2[0];\n                  verifier = _yield$this$createCha2[1];\n\n                  if (this.saveNoncesInLocalStorage && typeof window['localStorage'] !== 'undefined') {\n                    localStorage.setItem('PKCE_verifier', verifier);\n                  } else {\n                    this._storage.setItem('PKCE_verifier', verifier);\n                  }\n\n                  url += '&code_challenge=' + challenge;\n                  url += '&code_challenge_method=S256';\n\n                case 23:\n                  if (loginHint) {\n                    url += '&login_hint=' + encodeURIComponent(loginHint);\n                  }\n\n                  if (that.resource) {\n                    url += '&resource=' + encodeURIComponent(that.resource);\n                  }\n\n                  if (that.oidc) {\n                    url += '&nonce=' + encodeURIComponent(nonce);\n                  }\n\n                  if (noPrompt) {\n                    url += '&prompt=none';\n                  }\n\n                  for (_i2 = 0, _Object$keys2 = Object.keys(params); _i2 < _Object$keys2.length; _i2++) {\n                    key = _Object$keys2[_i2];\n                    url += '&' + encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\n                  }\n\n                  if (this.customQueryParams) {\n                    _iterator5 = _createForOfIteratorHelper(Object.getOwnPropertyNames(this.customQueryParams));\n\n                    try {\n                      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                        _key3 = _step5.value;\n                        url += '&' + _key3 + '=' + encodeURIComponent(this.customQueryParams[_key3]);\n                      }\n                    } catch (err) {\n                      _iterator5.e(err);\n                    } finally {\n                      _iterator5.f();\n                    }\n                  }\n\n                  return _context3.abrupt(\"return\", url);\n\n                case 30:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this);\n        }));\n      }\n    }, {\n      key: \"initImplicitFlowInternal\",\n      value: function initImplicitFlowInternal() {\n        var _this25 = this;\n\n        var additionalState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n        if (this.inImplicitFlow) {\n          return;\n        }\n\n        this.inImplicitFlow = true;\n\n        if (!this.validateUrlForHttps(this.loginUrl)) {\n          throw new Error(\"loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n        }\n\n        var addParams = {};\n        var loginHint = null;\n\n        if (typeof params === 'string') {\n          loginHint = params;\n        } else if (typeof params === 'object') {\n          addParams = params;\n        }\n\n        this.createLoginUrl(additionalState, loginHint, null, false, addParams).then(this.config.openUri).catch(function (error) {\n          console.error('Error in initImplicitFlow', error);\n          _this25.inImplicitFlow = false;\n        });\n      }\n      /**\r\n       * Starts the implicit flow and redirects to user to\r\n       * the auth servers' login url.\r\n       *\r\n       * @param additionalState Optional state that is passed around.\r\n       *  You'll find this state in the property `state` after `tryLogin` logged in the user.\r\n       * @param params Hash with additional parameter. If it is a string, it is used for the\r\n       *               parameter loginHint (for the sake of compatibility with former versions)\r\n       */\n\n    }, {\n      key: \"initImplicitFlow\",\n      value: function initImplicitFlow() {\n        var _this26 = this;\n\n        var additionalState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n        if (this.loginUrl !== '') {\n          this.initImplicitFlowInternal(additionalState, params);\n        } else {\n          this.events.pipe(filter(function (e) {\n            return e.type === 'discovery_document_loaded';\n          })).subscribe(function (_) {\n            return _this26.initImplicitFlowInternal(additionalState, params);\n          });\n        }\n      }\n      /**\r\n       * Reset current implicit flow\r\n       *\r\n       * @description This method allows resetting the current implict flow in order to be initialized again.\r\n       */\n\n    }, {\n      key: \"resetImplicitFlow\",\n      value: function resetImplicitFlow() {\n        this.inImplicitFlow = false;\n      }\n    }, {\n      key: \"callOnTokenReceivedIfExists\",\n      value: function callOnTokenReceivedIfExists(options) {\n        var that = this;\n\n        if (options.onTokenReceived) {\n          var tokenParams = {\n            idClaims: that.getIdentityClaims(),\n            idToken: that.getIdToken(),\n            accessToken: that.getAccessToken(),\n            state: that.state\n          };\n          options.onTokenReceived(tokenParams);\n        }\n      }\n    }, {\n      key: \"storeAccessTokenResponse\",\n      value: function storeAccessTokenResponse(accessToken, refreshToken, expiresIn, grantedScopes, customParameters) {\n        var _this27 = this;\n\n        this._storage.setItem('access_token', accessToken);\n\n        if (grantedScopes && !Array.isArray(grantedScopes)) {\n          this._storage.setItem('granted_scopes', JSON.stringify(grantedScopes.split(' ')));\n        } else if (grantedScopes && Array.isArray(grantedScopes)) {\n          this._storage.setItem('granted_scopes', JSON.stringify(grantedScopes));\n        }\n\n        this._storage.setItem('access_token_stored_at', '' + this.dateTimeService.now());\n\n        if (expiresIn) {\n          var expiresInMilliSeconds = expiresIn * 1000;\n          var now = this.dateTimeService.new();\n          var expiresAt = now.getTime() + expiresInMilliSeconds;\n\n          this._storage.setItem('expires_at', '' + expiresAt);\n        }\n\n        if (refreshToken) {\n          this._storage.setItem('refresh_token', refreshToken);\n        }\n\n        if (customParameters) {\n          customParameters.forEach(function (value, key) {\n            _this27._storage.setItem(key, value);\n          });\n        }\n      }\n      /**\r\n       * Delegates to tryLoginImplicitFlow for the sake of competability\r\n       * @param options Optional options.\r\n       */\n\n    }, {\n      key: \"tryLogin\",\n      value: function tryLogin() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n        if (this.config.responseType === 'code') {\n          return this.tryLoginCodeFlow(options).then(function (_) {\n            return true;\n          });\n        } else {\n          return this.tryLoginImplicitFlow(options);\n        }\n      }\n    }, {\n      key: \"parseQueryString\",\n      value: function parseQueryString(queryString) {\n        if (!queryString || queryString.length === 0) {\n          return {};\n        }\n\n        if (queryString.charAt(0) === '?') {\n          queryString = queryString.substr(1);\n        }\n\n        return this.urlHelper.parseQueryString(queryString);\n      }\n    }, {\n      key: \"tryLoginCodeFlow\",\n      value: function tryLoginCodeFlow() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n          var querySource, parts, code, state, sessionState, href, _this$parseState, _this$parseState2, nonceInState, userState, _err2, success, event;\n\n          return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n            while (1) {\n              switch (_context4.prev = _context4.next) {\n                case 0:\n                  options = options || {};\n                  querySource = options.customHashFragment ? options.customHashFragment.substring(1) : window.location.search;\n                  parts = this.getCodePartsFromUrl(querySource);\n                  code = parts['code'];\n                  state = parts['state'];\n                  sessionState = parts['session_state'];\n\n                  if (!options.preventClearHashAfterLogin) {\n                    href = location.origin + location.pathname + location.search.replace(/code=[^&\\$]*/, '').replace(/scope=[^&\\$]*/, '').replace(/state=[^&\\$]*/, '').replace(/session_state=[^&\\$]*/, '').replace(/^\\?&/, '?').replace(/&$/, '').replace(/^\\?$/, '').replace(/&+/g, '&').replace(/\\?&/, '?').replace(/\\?$/, '') + location.hash;\n                    history.replaceState(null, window.name, href);\n                  }\n\n                  _this$parseState = this.parseState(state), _this$parseState2 = _slicedToArray(_this$parseState, 2), nonceInState = _this$parseState2[0], userState = _this$parseState2[1];\n                  this.state = userState;\n\n                  if (!parts['error']) {\n                    _context4.next = 15;\n                    break;\n                  }\n\n                  this.debug('error trying to login');\n                  this.handleLoginError(options, parts);\n                  _err2 = new OAuthErrorEvent('code_error', {}, parts);\n                  this.eventsSubject.next(_err2);\n                  return _context4.abrupt(\"return\", Promise.reject(_err2));\n\n                case 15:\n                  if (options.disableNonceCheck) {\n                    _context4.next = 34;\n                    break;\n                  }\n\n                  if (nonceInState) {\n                    _context4.next = 19;\n                    break;\n                  }\n\n                  this.saveRequestedRoute();\n                  return _context4.abrupt(\"return\", Promise.resolve());\n\n                case 19:\n                  if (options.disableOAuth2StateCheck) {\n                    _context4.next = 25;\n                    break;\n                  }\n\n                  success = this.validateNonce(nonceInState);\n\n                  if (success) {\n                    _context4.next = 25;\n                    break;\n                  }\n\n                  event = new OAuthErrorEvent('invalid_nonce_in_state', null);\n                  this.eventsSubject.next(event);\n                  return _context4.abrupt(\"return\", Promise.reject(event));\n\n                case 25:\n                  this.storeSessionState(sessionState);\n\n                  if (!code) {\n                    _context4.next = 33;\n                    break;\n                  }\n\n                  _context4.next = 29;\n                  return this.getTokenFromCode(code, options);\n\n                case 29:\n                  this.restoreRequestedRoute();\n                  return _context4.abrupt(\"return\", Promise.resolve());\n\n                case 33:\n                  return _context4.abrupt(\"return\", Promise.resolve());\n\n                case 34:\n                  return _context4.abrupt(\"return\", Promise.reject());\n\n                case 35:\n                case \"end\":\n                  return _context4.stop();\n              }\n            }\n          }, _callee4, this);\n        }));\n      }\n    }, {\n      key: \"saveRequestedRoute\",\n      value: function saveRequestedRoute() {\n        if (this.config.preserveRequestedRoute) {\n          this._storage.setItem('requested_route', window.location.pathname + window.location.search);\n        }\n      }\n    }, {\n      key: \"restoreRequestedRoute\",\n      value: function restoreRequestedRoute() {\n        var requestedRoute = this._storage.getItem('requested_route');\n\n        if (requestedRoute) {\n          history.replaceState(null, '', window.location.origin + requestedRoute);\n        }\n      }\n      /**\r\n       * Retrieve the returned auth code from the redirect uri that has been called.\r\n       * If required also check hash, as we could use hash location strategy.\r\n       */\n\n    }, {\n      key: \"getCodePartsFromUrl\",\n      value: function getCodePartsFromUrl(queryString) {\n        if (!queryString || queryString.length === 0) {\n          return this.urlHelper.getHashFragmentParams();\n        } // normalize query string\n\n\n        if (queryString.charAt(0) === '?') {\n          queryString = queryString.substr(1);\n        }\n\n        return this.urlHelper.parseQueryString(queryString);\n      }\n      /**\r\n       * Get token using an intermediate code. Works for the Authorization Code flow.\r\n       */\n\n    }, {\n      key: \"getTokenFromCode\",\n      value: function getTokenFromCode(code, options) {\n        var params = new HttpParams({\n          encoder: new WebHttpUrlEncodingCodec()\n        }).set('grant_type', 'authorization_code').set('code', code).set('redirect_uri', options.customRedirectUri || this.redirectUri);\n\n        if (!this.disablePKCE) {\n          var PKCEVerifier;\n\n          if (this.saveNoncesInLocalStorage && typeof window['localStorage'] !== 'undefined') {\n            PKCEVerifier = localStorage.getItem('PKCE_verifier');\n          } else {\n            PKCEVerifier = this._storage.getItem('PKCE_verifier');\n          }\n\n          if (!PKCEVerifier) {\n            console.warn('No PKCE verifier found in oauth storage!');\n          } else {\n            params = params.set('code_verifier', PKCEVerifier);\n          }\n        }\n\n        return this.fetchAndProcessToken(params, options);\n      }\n    }, {\n      key: \"fetchAndProcessToken\",\n      value: function fetchAndProcessToken(params, options) {\n        var _this28 = this;\n\n        options = options || {};\n        this.assertUrlNotNullAndCorrectProtocol(this.tokenEndpoint, 'tokenEndpoint');\n        var headers = new HttpHeaders().set('Content-Type', 'application/x-www-form-urlencoded');\n\n        if (this.useHttpBasicAuth) {\n          var header = btoa(\"\".concat(this.clientId, \":\").concat(this.dummyClientSecret));\n          headers = headers.set('Authorization', 'Basic ' + header);\n        }\n\n        if (!this.useHttpBasicAuth) {\n          params = params.set('client_id', this.clientId);\n        }\n\n        if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n          params = params.set('client_secret', this.dummyClientSecret);\n        }\n\n        return new Promise(function (resolve, reject) {\n          if (_this28.customQueryParams) {\n            var _iterator6 = _createForOfIteratorHelper(Object.getOwnPropertyNames(_this28.customQueryParams)),\n                _step6;\n\n            try {\n              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                var key = _step6.value;\n                params = params.set(key, _this28.customQueryParams[key]);\n              }\n            } catch (err) {\n              _iterator6.e(err);\n            } finally {\n              _iterator6.f();\n            }\n          }\n\n          _this28.http.post(_this28.tokenEndpoint, params, {\n            headers: headers\n          }).subscribe(function (tokenResponse) {\n            _this28.debug('refresh tokenResponse', tokenResponse);\n\n            _this28.storeAccessTokenResponse(tokenResponse.access_token, tokenResponse.refresh_token, tokenResponse.expires_in || _this28.fallbackAccessTokenExpirationTimeInSec, tokenResponse.scope, _this28.extractRecognizedCustomParameters(tokenResponse));\n\n            if (_this28.oidc && tokenResponse.id_token) {\n              _this28.processIdToken(tokenResponse.id_token, tokenResponse.access_token, options.disableNonceCheck).then(function (result) {\n                _this28.storeIdToken(result);\n\n                _this28.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n\n                _this28.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n\n                resolve(tokenResponse);\n              }).catch(function (reason) {\n                _this28.eventsSubject.next(new OAuthErrorEvent('token_validation_error', reason));\n\n                console.error('Error validating tokens');\n                console.error(reason);\n                reject(reason);\n              });\n            } else {\n              _this28.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n\n              _this28.eventsSubject.next(new OAuthSuccessEvent('token_refreshed'));\n\n              resolve(tokenResponse);\n            }\n          }, function (err) {\n            console.error('Error getting token', err);\n\n            _this28.eventsSubject.next(new OAuthErrorEvent('token_refresh_error', err));\n\n            reject(err);\n          });\n        });\n      }\n      /**\r\n       * Checks whether there are tokens in the hash fragment\r\n       * as a result of the implicit flow. These tokens are\r\n       * parsed, validated and used to sign the user in to the\r\n       * current client.\r\n       *\r\n       * @param options Optional options.\r\n       */\n\n    }, {\n      key: \"tryLoginImplicitFlow\",\n      value: function tryLoginImplicitFlow() {\n        var _this29 = this;\n\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        options = options || {};\n        var parts;\n\n        if (options.customHashFragment) {\n          parts = this.urlHelper.getHashFragmentParams(options.customHashFragment);\n        } else {\n          parts = this.urlHelper.getHashFragmentParams();\n        }\n\n        this.debug('parsed url', parts);\n        var state = parts['state'];\n\n        var _this$parseState3 = this.parseState(state),\n            _this$parseState4 = _slicedToArray(_this$parseState3, 2),\n            nonceInState = _this$parseState4[0],\n            userState = _this$parseState4[1];\n\n        this.state = userState;\n\n        if (parts['error']) {\n          this.debug('error trying to login');\n          this.handleLoginError(options, parts);\n\n          var _err3 = new OAuthErrorEvent('token_error', {}, parts);\n\n          this.eventsSubject.next(_err3);\n          return Promise.reject(_err3);\n        }\n\n        var accessToken = parts['access_token'];\n        var idToken = parts['id_token'];\n        var sessionState = parts['session_state'];\n        var grantedScopes = parts['scope'];\n\n        if (!this.requestAccessToken && !this.oidc) {\n          return Promise.reject('Either requestAccessToken or oidc (or both) must be true.');\n        }\n\n        if (this.requestAccessToken && !accessToken) {\n          return Promise.resolve(false);\n        }\n\n        if (this.requestAccessToken && !options.disableOAuth2StateCheck && !state) {\n          return Promise.resolve(false);\n        }\n\n        if (this.oidc && !idToken) {\n          return Promise.resolve(false);\n        }\n\n        if (this.sessionChecksEnabled && !sessionState) {\n          this.logger.warn('session checks (Session Status Change Notification) ' + 'were activated in the configuration but the id_token ' + 'does not contain a session_state claim');\n        }\n\n        if (this.requestAccessToken && !options.disableNonceCheck) {\n          var success = this.validateNonce(nonceInState);\n\n          if (!success) {\n            var event = new OAuthErrorEvent('invalid_nonce_in_state', null);\n            this.eventsSubject.next(event);\n            return Promise.reject(event);\n          }\n        }\n\n        if (this.requestAccessToken) {\n          this.storeAccessTokenResponse(accessToken, null, parts['expires_in'] || this.fallbackAccessTokenExpirationTimeInSec, grantedScopes);\n        }\n\n        if (!this.oidc) {\n          this.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n\n          if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\n            this.clearLocationHash();\n          }\n\n          this.callOnTokenReceivedIfExists(options);\n          return Promise.resolve(true);\n        }\n\n        return this.processIdToken(idToken, accessToken, options.disableNonceCheck).then(function (result) {\n          if (options.validationHandler) {\n            return options.validationHandler({\n              accessToken: accessToken,\n              idClaims: result.idTokenClaims,\n              idToken: result.idToken,\n              state: state\n            }).then(function (_) {\n              return result;\n            });\n          }\n\n          return result;\n        }).then(function (result) {\n          _this29.storeIdToken(result);\n\n          _this29.storeSessionState(sessionState);\n\n          if (_this29.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\n            _this29.clearLocationHash();\n          }\n\n          _this29.eventsSubject.next(new OAuthSuccessEvent('token_received'));\n\n          _this29.callOnTokenReceivedIfExists(options);\n\n          _this29.inImplicitFlow = false;\n          return true;\n        }).catch(function (reason) {\n          _this29.eventsSubject.next(new OAuthErrorEvent('token_validation_error', reason));\n\n          _this29.logger.error('Error validating tokens');\n\n          _this29.logger.error(reason);\n\n          return Promise.reject(reason);\n        });\n      }\n    }, {\n      key: \"parseState\",\n      value: function parseState(state) {\n        var nonce = state;\n        var userState = '';\n\n        if (state) {\n          var idx = state.indexOf(this.config.nonceStateSeparator);\n\n          if (idx > -1) {\n            nonce = state.substr(0, idx);\n            userState = state.substr(idx + this.config.nonceStateSeparator.length);\n          }\n        }\n\n        return [nonce, userState];\n      }\n    }, {\n      key: \"validateNonce\",\n      value: function validateNonce(nonceInState) {\n        var savedNonce;\n\n        if (this.saveNoncesInLocalStorage && typeof window['localStorage'] !== 'undefined') {\n          savedNonce = localStorage.getItem('nonce');\n        } else {\n          savedNonce = this._storage.getItem('nonce');\n        }\n\n        if (savedNonce !== nonceInState) {\n          var _err4 = 'Validating access_token failed, wrong state/nonce.';\n          console.error(_err4, savedNonce, nonceInState);\n          return false;\n        }\n\n        return true;\n      }\n    }, {\n      key: \"storeIdToken\",\n      value: function storeIdToken(idToken) {\n        this._storage.setItem('id_token', idToken.idToken);\n\n        this._storage.setItem('id_token_claims_obj', idToken.idTokenClaimsJson);\n\n        this._storage.setItem('id_token_expires_at', '' + idToken.idTokenExpiresAt);\n\n        this._storage.setItem('id_token_stored_at', '' + this.dateTimeService.now());\n      }\n    }, {\n      key: \"storeSessionState\",\n      value: function storeSessionState(sessionState) {\n        this._storage.setItem('session_state', sessionState);\n      }\n    }, {\n      key: \"getSessionState\",\n      value: function getSessionState() {\n        return this._storage.getItem('session_state');\n      }\n    }, {\n      key: \"handleLoginError\",\n      value: function handleLoginError(options, parts) {\n        if (options.onLoginError) {\n          options.onLoginError(parts);\n        }\n\n        if (this.clearHashAfterLogin && !options.preventClearHashAfterLogin) {\n          this.clearLocationHash();\n        }\n      }\n    }, {\n      key: \"getClockSkewInMsec\",\n      value: function getClockSkewInMsec() {\n        var defaultSkewMsc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 600000;\n\n        if (!this.clockSkewInSec) {\n          return defaultSkewMsc;\n        }\n\n        return this.clockSkewInSec * 1000;\n      }\n      /**\r\n       * @ignore\r\n       */\n\n    }, {\n      key: \"processIdToken\",\n      value: function processIdToken(idToken, accessToken) {\n        var _this30 = this;\n\n        var skipNonceCheck = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var tokenParts = idToken.split('.');\n        var headerBase64 = this.padBase64(tokenParts[0]);\n        var headerJson = b64DecodeUnicode(headerBase64);\n        var header = JSON.parse(headerJson);\n        var claimsBase64 = this.padBase64(tokenParts[1]);\n        var claimsJson = b64DecodeUnicode(claimsBase64);\n        var claims = JSON.parse(claimsJson);\n        var savedNonce;\n\n        if (this.saveNoncesInLocalStorage && typeof window['localStorage'] !== 'undefined') {\n          savedNonce = localStorage.getItem('nonce');\n        } else {\n          savedNonce = this._storage.getItem('nonce');\n        }\n\n        if (Array.isArray(claims.aud)) {\n          if (claims.aud.every(function (v) {\n            return v !== _this30.clientId;\n          })) {\n            var _err5 = 'Wrong audience: ' + claims.aud.join(',');\n\n            this.logger.warn(_err5);\n            return Promise.reject(_err5);\n          }\n        } else {\n          if (claims.aud !== this.clientId) {\n            var _err6 = 'Wrong audience: ' + claims.aud;\n\n            this.logger.warn(_err6);\n            return Promise.reject(_err6);\n          }\n        }\n\n        if (!claims.sub) {\n          var _err7 = 'No sub claim in id_token';\n          this.logger.warn(_err7);\n          return Promise.reject(_err7);\n        }\n        /* For now, we only check whether the sub against\r\n         * silentRefreshSubject when sessionChecksEnabled is on\r\n         * We will reconsider in a later version to do this\r\n         * in every other case too.\r\n         */\n\n\n        if (this.sessionChecksEnabled && this.silentRefreshSubject && this.silentRefreshSubject !== claims['sub']) {\n          var _err8 = 'After refreshing, we got an id_token for another user (sub). ' + \"Expected sub: \".concat(this.silentRefreshSubject, \", received sub: \").concat(claims['sub']);\n\n          this.logger.warn(_err8);\n          return Promise.reject(_err8);\n        }\n\n        if (!claims.iat) {\n          var _err9 = 'No iat claim in id_token';\n          this.logger.warn(_err9);\n          return Promise.reject(_err9);\n        }\n\n        if (!this.skipIssuerCheck && claims.iss !== this.issuer) {\n          var _err10 = 'Wrong issuer: ' + claims.iss;\n\n          this.logger.warn(_err10);\n          return Promise.reject(_err10);\n        }\n\n        if (!skipNonceCheck && claims.nonce !== savedNonce) {\n          var _err11 = 'Wrong nonce: ' + claims.nonce;\n\n          this.logger.warn(_err11);\n          return Promise.reject(_err11);\n        } // at_hash is not applicable to authorization code flow\n        // addressing https://github.com/manfredsteyer/angular-oauth2-oidc/issues/661\n        // i.e. Based on spec the at_hash check is only true for implicit code flow on Ping Federate\n        // https://www.pingidentity.com/developer/en/resources/openid-connect-developers-guide.html\n\n\n        if (this.hasOwnProperty('responseType') && (this.responseType === 'code' || this.responseType === 'id_token')) {\n          this.disableAtHashCheck = true;\n        }\n\n        if (!this.disableAtHashCheck && this.requestAccessToken && !claims['at_hash']) {\n          var _err12 = 'An at_hash is needed!';\n          this.logger.warn(_err12);\n          return Promise.reject(_err12);\n        }\n\n        var now = this.dateTimeService.now();\n        var issuedAtMSec = claims.iat * 1000;\n        var expiresAtMSec = claims.exp * 1000;\n        var clockSkewInMSec = this.getClockSkewInMsec(); // (this.getClockSkewInMsec() || 600) * 1000;\n\n        if (issuedAtMSec - clockSkewInMSec >= now || expiresAtMSec + clockSkewInMSec <= now) {\n          var _err13 = 'Token has expired';\n          console.error(_err13);\n          console.error({\n            now: now,\n            issuedAtMSec: issuedAtMSec,\n            expiresAtMSec: expiresAtMSec\n          });\n          return Promise.reject(_err13);\n        }\n\n        var validationParams = {\n          accessToken: accessToken,\n          idToken: idToken,\n          jwks: this.jwks,\n          idTokenClaims: claims,\n          idTokenHeader: header,\n          loadKeys: function loadKeys() {\n            return _this30.loadJwks();\n          }\n        };\n\n        if (this.disableAtHashCheck) {\n          return this.checkSignature(validationParams).then(function (_) {\n            var result = {\n              idToken: idToken,\n              idTokenClaims: claims,\n              idTokenClaimsJson: claimsJson,\n              idTokenHeader: header,\n              idTokenHeaderJson: headerJson,\n              idTokenExpiresAt: expiresAtMSec\n            };\n            return result;\n          });\n        }\n\n        return this.checkAtHash(validationParams).then(function (atHashValid) {\n          if (!_this30.disableAtHashCheck && _this30.requestAccessToken && !atHashValid) {\n            var _err14 = 'Wrong at_hash';\n\n            _this30.logger.warn(_err14);\n\n            return Promise.reject(_err14);\n          }\n\n          return _this30.checkSignature(validationParams).then(function (_) {\n            var atHashCheckEnabled = !_this30.disableAtHashCheck;\n            var result = {\n              idToken: idToken,\n              idTokenClaims: claims,\n              idTokenClaimsJson: claimsJson,\n              idTokenHeader: header,\n              idTokenHeaderJson: headerJson,\n              idTokenExpiresAt: expiresAtMSec\n            };\n\n            if (atHashCheckEnabled) {\n              return _this30.checkAtHash(validationParams).then(function (atHashValid) {\n                if (_this30.requestAccessToken && !atHashValid) {\n                  var _err15 = 'Wrong at_hash';\n\n                  _this30.logger.warn(_err15);\n\n                  return Promise.reject(_err15);\n                } else {\n                  return result;\n                }\n              });\n            } else {\n              return result;\n            }\n          });\n        });\n      }\n      /**\r\n       * Returns the received claims about the user.\r\n       */\n\n    }, {\n      key: \"getIdentityClaims\",\n      value: function getIdentityClaims() {\n        var claims = this._storage.getItem('id_token_claims_obj');\n\n        if (!claims) {\n          return null;\n        }\n\n        return JSON.parse(claims);\n      }\n      /**\r\n       * Returns the granted scopes from the server.\r\n       */\n\n    }, {\n      key: \"getGrantedScopes\",\n      value: function getGrantedScopes() {\n        var scopes = this._storage.getItem('granted_scopes');\n\n        if (!scopes) {\n          return null;\n        }\n\n        return JSON.parse(scopes);\n      }\n      /**\r\n       * Returns the current id_token.\r\n       */\n\n    }, {\n      key: \"getIdToken\",\n      value: function getIdToken() {\n        return this._storage ? this._storage.getItem('id_token') : null;\n      }\n    }, {\n      key: \"padBase64\",\n      value: function padBase64(base64data) {\n        while (base64data.length % 4 !== 0) {\n          base64data += '=';\n        }\n\n        return base64data;\n      }\n      /**\r\n       * Returns the current access_token.\r\n       */\n\n    }, {\n      key: \"getAccessToken\",\n      value: function getAccessToken() {\n        return this._storage ? this._storage.getItem('access_token') : null;\n      }\n    }, {\n      key: \"getRefreshToken\",\n      value: function getRefreshToken() {\n        return this._storage ? this._storage.getItem('refresh_token') : null;\n      }\n      /**\r\n       * Returns the expiration date of the access_token\r\n       * as milliseconds since 1970.\r\n       */\n\n    }, {\n      key: \"getAccessTokenExpiration\",\n      value: function getAccessTokenExpiration() {\n        if (!this._storage.getItem('expires_at')) {\n          return null;\n        }\n\n        return parseInt(this._storage.getItem('expires_at'), 10);\n      }\n    }, {\n      key: \"getAccessTokenStoredAt\",\n      value: function getAccessTokenStoredAt() {\n        return parseInt(this._storage.getItem('access_token_stored_at'), 10);\n      }\n    }, {\n      key: \"getIdTokenStoredAt\",\n      value: function getIdTokenStoredAt() {\n        return parseInt(this._storage.getItem('id_token_stored_at'), 10);\n      }\n      /**\r\n       * Returns the expiration date of the id_token\r\n       * as milliseconds since 1970.\r\n       */\n\n    }, {\n      key: \"getIdTokenExpiration\",\n      value: function getIdTokenExpiration() {\n        if (!this._storage.getItem('id_token_expires_at')) {\n          return null;\n        }\n\n        return parseInt(this._storage.getItem('id_token_expires_at'), 10);\n      }\n      /**\r\n       * Checkes, whether there is a valid access_token.\r\n       */\n\n    }, {\n      key: \"hasValidAccessToken\",\n      value: function hasValidAccessToken() {\n        if (this.getAccessToken()) {\n          var expiresAt = this._storage.getItem('expires_at');\n\n          var now = this.dateTimeService.new();\n\n          if (expiresAt && parseInt(expiresAt, 10) < now.getTime() - this.getClockSkewInMsec()) {\n            return false;\n          }\n\n          return true;\n        }\n\n        return false;\n      }\n      /**\r\n       * Checks whether there is a valid id_token.\r\n       */\n\n    }, {\n      key: \"hasValidIdToken\",\n      value: function hasValidIdToken() {\n        if (this.getIdToken()) {\n          var expiresAt = this._storage.getItem('id_token_expires_at');\n\n          var now = this.dateTimeService.new();\n\n          if (expiresAt && parseInt(expiresAt, 10) < now.getTime() - this.getClockSkewInMsec()) {\n            return false;\n          }\n\n          return true;\n        }\n\n        return false;\n      }\n      /**\r\n       * Retrieve a saved custom property of the TokenReponse object. Only if predefined in authconfig.\r\n       */\n\n    }, {\n      key: \"getCustomTokenResponseProperty\",\n      value: function getCustomTokenResponseProperty(requestedProperty) {\n        return this._storage && this.config.customTokenParameters && this.config.customTokenParameters.indexOf(requestedProperty) >= 0 && this._storage.getItem(requestedProperty) !== null ? JSON.parse(this._storage.getItem(requestedProperty)) : null;\n      }\n      /**\r\n       * Returns the auth-header that can be used\r\n       * to transmit the access_token to a service\r\n       */\n\n    }, {\n      key: \"authorizationHeader\",\n      value: function authorizationHeader() {\n        return 'Bearer ' + this.getAccessToken();\n      }\n    }, {\n      key: \"logOut\",\n      value: function logOut() {\n        var _this31 = this;\n\n        var customParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n        var noRedirectToLogoutUrl = false;\n\n        if (typeof customParameters === 'boolean') {\n          noRedirectToLogoutUrl = customParameters;\n          customParameters = {};\n        }\n\n        var id_token = this.getIdToken();\n\n        this._storage.removeItem('access_token');\n\n        this._storage.removeItem('id_token');\n\n        this._storage.removeItem('refresh_token');\n\n        if (this.saveNoncesInLocalStorage) {\n          localStorage.removeItem('nonce');\n          localStorage.removeItem('PKCE_verifier');\n        } else {\n          this._storage.removeItem('nonce');\n\n          this._storage.removeItem('PKCE_verifier');\n        }\n\n        this._storage.removeItem('expires_at');\n\n        this._storage.removeItem('id_token_claims_obj');\n\n        this._storage.removeItem('id_token_expires_at');\n\n        this._storage.removeItem('id_token_stored_at');\n\n        this._storage.removeItem('access_token_stored_at');\n\n        this._storage.removeItem('granted_scopes');\n\n        this._storage.removeItem('session_state');\n\n        if (this.config.customTokenParameters) {\n          this.config.customTokenParameters.forEach(function (customParam) {\n            return _this31._storage.removeItem(customParam);\n          });\n        }\n\n        this.silentRefreshSubject = null;\n        this.eventsSubject.next(new OAuthInfoEvent('logout'));\n\n        if (!this.logoutUrl) {\n          return;\n        }\n\n        if (noRedirectToLogoutUrl) {\n          return;\n        }\n\n        if (!id_token && !this.postLogoutRedirectUri) {\n          return;\n        }\n\n        var logoutUrl;\n\n        if (!this.validateUrlForHttps(this.logoutUrl)) {\n          throw new Error(\"logoutUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n        } // For backward compatibility\n\n\n        if (this.logoutUrl.indexOf('{{') > -1) {\n          logoutUrl = this.logoutUrl.replace(/\\{\\{id_token\\}\\}/, encodeURIComponent(id_token)).replace(/\\{\\{client_id\\}\\}/, encodeURIComponent(this.clientId));\n        } else {\n          var params = new HttpParams({\n            encoder: new WebHttpUrlEncodingCodec()\n          });\n\n          if (id_token) {\n            params = params.set('id_token_hint', id_token);\n          }\n\n          var postLogoutUrl = this.postLogoutRedirectUri || this.redirectUriAsPostLogoutRedirectUriFallback && this.redirectUri || '';\n\n          if (postLogoutUrl) {\n            params = params.set('post_logout_redirect_uri', postLogoutUrl);\n\n            if (state) {\n              params = params.set('state', state);\n            }\n          }\n\n          for (var key in customParameters) {\n            params = params.set(key, customParameters[key]);\n          }\n\n          logoutUrl = this.logoutUrl + (this.logoutUrl.indexOf('?') > -1 ? '&' : '?') + params.toString();\n        }\n\n        this.config.openUri(logoutUrl);\n      }\n      /**\r\n       * @ignore\r\n       */\n\n    }, {\n      key: \"createAndSaveNonce\",\n      value: function createAndSaveNonce() {\n        var that = this;\n        return this.createNonce().then(function (nonce) {\n          // Use localStorage for nonce if possible\n          // localStorage is the only storage who survives a\n          // redirect in ALL browsers (also IE)\n          // Otherwiese we'd force teams who have to support\n          // IE into using localStorage for everything\n          if (that.saveNoncesInLocalStorage && typeof window['localStorage'] !== 'undefined') {\n            localStorage.setItem('nonce', nonce);\n          } else {\n            that._storage.setItem('nonce', nonce);\n          }\n\n          return nonce;\n        });\n      }\n      /**\r\n       * @ignore\r\n       */\n\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.clearAccessTokenTimer();\n        this.clearIdTokenTimer();\n        this.removeSilentRefreshEventListener();\n        var silentRefreshFrame = this.document.getElementById(this.silentRefreshIFrameName);\n\n        if (silentRefreshFrame) {\n          silentRefreshFrame.remove();\n        }\n\n        this.stopSessionCheckTimer();\n        this.removeSessionCheckEventListener();\n        var sessionCheckFrame = this.document.getElementById(this.sessionCheckIFrameName);\n\n        if (sessionCheckFrame) {\n          sessionCheckFrame.remove();\n        }\n      }\n    }, {\n      key: \"createNonce\",\n      value: function createNonce() {\n        var _this32 = this;\n\n        return new Promise(function (resolve) {\n          if (_this32.rngUrl) {\n            throw new Error('createNonce with rng-web-api has not been implemented so far');\n          }\n          /*\r\n           * This alphabet is from:\r\n           * https://tools.ietf.org/html/rfc7636#section-4.1\r\n           *\r\n           * [A-Z] / [a-z] / [0-9] / \"-\" / \".\" / \"_\" / \"~\"\r\n           */\n\n\n          var unreserved = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';\n          var size = 45;\n          var id = '';\n          var crypto = typeof self === 'undefined' ? null : self.crypto || self['msCrypto'];\n\n          if (crypto) {\n            var bytes = new Uint8Array(size);\n            crypto.getRandomValues(bytes); // Needed for IE\n\n            if (!bytes.map) {\n              bytes.map = Array.prototype.map;\n            }\n\n            bytes = bytes.map(function (x) {\n              return unreserved.charCodeAt(x % unreserved.length);\n            });\n            id = String.fromCharCode.apply(null, bytes);\n          } else {\n            while (0 < size--) {\n              id += unreserved[Math.random() * unreserved.length | 0];\n            }\n          }\n\n          resolve(base64UrlEncode(id));\n        });\n      }\n    }, {\n      key: \"checkAtHash\",\n      value: function checkAtHash(params) {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n          return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  if (this.tokenValidationHandler) {\n                    _context5.next = 3;\n                    break;\n                  }\n\n                  this.logger.warn('No tokenValidationHandler configured. Cannot check at_hash.');\n                  return _context5.abrupt(\"return\", true);\n\n                case 3:\n                  return _context5.abrupt(\"return\", this.tokenValidationHandler.validateAtHash(params));\n\n                case 4:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5, this);\n        }));\n      }\n    }, {\n      key: \"checkSignature\",\n      value: function checkSignature(params) {\n        if (!this.tokenValidationHandler) {\n          this.logger.warn('No tokenValidationHandler configured. Cannot check signature.');\n          return Promise.resolve(null);\n        }\n\n        return this.tokenValidationHandler.validateSignature(params);\n      }\n      /**\r\n       * Start the implicit flow or the code flow,\r\n       * depending on your configuration.\r\n       */\n\n    }, {\n      key: \"initLoginFlow\",\n      value: function initLoginFlow() {\n        var additionalState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        if (this.responseType === 'code') {\n          return this.initCodeFlow(additionalState, params);\n        } else {\n          return this.initImplicitFlow(additionalState, params);\n        }\n      }\n      /**\r\n       * Starts the authorization code flow and redirects to user to\r\n       * the auth servers login url.\r\n       */\n\n    }, {\n      key: \"initCodeFlow\",\n      value: function initCodeFlow() {\n        var _this33 = this;\n\n        var additionalState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        if (this.loginUrl !== '') {\n          this.initCodeFlowInternal(additionalState, params);\n        } else {\n          this.events.pipe(filter(function (e) {\n            return e.type === 'discovery_document_loaded';\n          })).subscribe(function (_) {\n            return _this33.initCodeFlowInternal(additionalState, params);\n          });\n        }\n      }\n    }, {\n      key: \"initCodeFlowInternal\",\n      value: function initCodeFlowInternal() {\n        var additionalState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        if (!this.validateUrlForHttps(this.loginUrl)) {\n          throw new Error(\"loginUrl  must use HTTPS (with TLS), or config value for property 'requireHttps' must be set to 'false' and allow HTTP (without TLS).\");\n        }\n\n        var addParams = {};\n        var loginHint = null;\n\n        if (typeof params === 'string') {\n          loginHint = params;\n        } else if (typeof params === 'object') {\n          addParams = params;\n        }\n\n        this.createLoginUrl(additionalState, loginHint, null, false, addParams).then(this.config.openUri).catch(function (error) {\n          console.error('Error in initAuthorizationCodeFlow');\n          console.error(error);\n        });\n      }\n    }, {\n      key: \"createChallangeVerifierPairForPKCE\",\n      value: function createChallangeVerifierPairForPKCE() {\n        return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n          var verifier, challengeRaw, challenge;\n          return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  if (this.crypto) {\n                    _context6.next = 2;\n                    break;\n                  }\n\n                  throw new Error('PKCE support for code flow needs a CryptoHander. Did you import the OAuthModule using forRoot() ?');\n\n                case 2:\n                  _context6.next = 4;\n                  return this.createNonce();\n\n                case 4:\n                  verifier = _context6.sent;\n                  _context6.next = 7;\n                  return this.crypto.calcHash(verifier, 'sha-256');\n\n                case 7:\n                  challengeRaw = _context6.sent;\n                  challenge = base64UrlEncode(challengeRaw);\n                  return _context6.abrupt(\"return\", [challenge, verifier]);\n\n                case 10:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }, _callee6, this);\n        }));\n      }\n    }, {\n      key: \"extractRecognizedCustomParameters\",\n      value: function extractRecognizedCustomParameters(tokenResponse) {\n        var foundParameters = new Map();\n\n        if (!this.config.customTokenParameters) {\n          return foundParameters;\n        }\n\n        this.config.customTokenParameters.forEach(function (recognizedParameter) {\n          if (tokenResponse[recognizedParameter]) {\n            foundParameters.set(recognizedParameter, JSON.stringify(tokenResponse[recognizedParameter]));\n          }\n        });\n        return foundParameters;\n      }\n      /**\r\n       * Revokes the auth token to secure the vulnarability\r\n       * of the token issued allowing the authorization server to clean\r\n       * up any security credentials associated with the authorization\r\n       */\n\n    }, {\n      key: \"revokeTokenAndLogout\",\n      value: function revokeTokenAndLogout() {\n        var _this34 = this;\n\n        var customParameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var ignoreCorsIssues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var revokeEndpoint = this.revocationEndpoint;\n        var accessToken = this.getAccessToken();\n        var refreshToken = this.getRefreshToken();\n\n        if (!accessToken) {\n          return;\n        }\n\n        var params = new HttpParams({\n          encoder: new WebHttpUrlEncodingCodec()\n        });\n        var headers = new HttpHeaders().set('Content-Type', 'application/x-www-form-urlencoded');\n\n        if (this.useHttpBasicAuth) {\n          var header = btoa(\"\".concat(this.clientId, \":\").concat(this.dummyClientSecret));\n          headers = headers.set('Authorization', 'Basic ' + header);\n        }\n\n        if (!this.useHttpBasicAuth) {\n          params = params.set('client_id', this.clientId);\n        }\n\n        if (!this.useHttpBasicAuth && this.dummyClientSecret) {\n          params = params.set('client_secret', this.dummyClientSecret);\n        }\n\n        if (this.customQueryParams) {\n          var _iterator7 = _createForOfIteratorHelper(Object.getOwnPropertyNames(this.customQueryParams)),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var key = _step7.value;\n              params = params.set(key, this.customQueryParams[key]);\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n        }\n\n        return new Promise(function (resolve, reject) {\n          var revokeAccessToken;\n          var revokeRefreshToken;\n\n          if (accessToken) {\n            var revokationParams = params.set('token', accessToken).set('token_type_hint', 'access_token');\n            revokeAccessToken = _this34.http.post(revokeEndpoint, revokationParams, {\n              headers: headers\n            });\n          } else {\n            revokeAccessToken = of(null);\n          }\n\n          if (refreshToken) {\n            var _revokationParams = params.set('token', refreshToken).set('token_type_hint', 'refresh_token');\n\n            revokeRefreshToken = _this34.http.post(revokeEndpoint, _revokationParams, {\n              headers: headers\n            });\n          } else {\n            revokeRefreshToken = of(null);\n          }\n\n          if (ignoreCorsIssues) {\n            revokeAccessToken = revokeAccessToken.pipe(catchError(function (err) {\n              if (err.status === 0) {\n                return of(null);\n              }\n\n              return throwError(err);\n            }));\n            revokeRefreshToken = revokeRefreshToken.pipe(catchError(function (err) {\n              if (err.status === 0) {\n                return of(null);\n              }\n\n              return throwError(err);\n            }));\n          }\n\n          combineLatest([revokeAccessToken, revokeRefreshToken]).subscribe(function (res) {\n            _this34.logOut(customParameters);\n\n            resolve(res);\n\n            _this34.logger.info('Token successfully revoked');\n          }, function (err) {\n            _this34.logger.error('Error revoking token', err);\n\n            _this34.eventsSubject.next(new OAuthErrorEvent('token_revoke_error', err));\n\n            reject(err);\n          });\n        });\n      }\n      /**\r\n       * Clear location.hash if it's present\r\n       */\n\n    }, {\n      key: \"clearLocationHash\",\n      value: function clearLocationHash() {\n        // Checking for empty hash is necessary for Firefox\n        // as setting an empty hash to an empty string adds # to the URL\n        if (location.hash != '') {\n          location.hash = '';\n        }\n      }\n    }]);\n\n    return OAuthService;\n  }(AuthConfig);\n\n  OAuthService.ɵfac = function OAuthService_Factory(t) {\n    return new (t || OAuthService)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(OAuthStorage, 8), i0.ɵɵinject(ValidationHandler, 8), i0.ɵɵinject(AuthConfig, 8), i0.ɵɵinject(UrlHelperService), i0.ɵɵinject(OAuthLogger), i0.ɵɵinject(HashHandler, 8), i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(DateTimeProvider));\n  };\n\n  OAuthService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OAuthService,\n    factory: OAuthService.ɵfac\n  });\n  return OAuthService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar OAuthModuleConfig = /*#__PURE__*/_createClass(function OAuthModuleConfig() {\n  _classCallCheck(this, OAuthModuleConfig);\n});\n\nvar OAuthResourceServerConfig = /*#__PURE__*/_createClass(function OAuthResourceServerConfig() {\n  _classCallCheck(this, OAuthResourceServerConfig);\n});\n\nvar OAuthResourceServerErrorHandler = /*#__PURE__*/_createClass(function OAuthResourceServerErrorHandler() {\n  _classCallCheck(this, OAuthResourceServerErrorHandler);\n});\n\nvar OAuthNoopResourceServerErrorHandler = /*#__PURE__*/function () {\n  function OAuthNoopResourceServerErrorHandler() {\n    _classCallCheck(this, OAuthNoopResourceServerErrorHandler);\n  }\n\n  _createClass(OAuthNoopResourceServerErrorHandler, [{\n    key: \"handleError\",\n    value: function handleError(err) {\n      return throwError(err);\n    }\n  }]);\n\n  return OAuthNoopResourceServerErrorHandler;\n}();\n\nvar DefaultOAuthInterceptor = /*#__PURE__*/(function () {\n  var DefaultOAuthInterceptor = /*#__PURE__*/function () {\n    function DefaultOAuthInterceptor(oAuthService, errorHandler, moduleConfig) {\n      _classCallCheck(this, DefaultOAuthInterceptor);\n\n      this.oAuthService = oAuthService;\n      this.errorHandler = errorHandler;\n      this.moduleConfig = moduleConfig;\n    }\n\n    _createClass(DefaultOAuthInterceptor, [{\n      key: \"checkUrl\",\n      value: function checkUrl(url) {\n        if (this.moduleConfig.resourceServer.customUrlValidation) {\n          return this.moduleConfig.resourceServer.customUrlValidation(url);\n        }\n\n        if (this.moduleConfig.resourceServer.allowedUrls) {\n          return !!this.moduleConfig.resourceServer.allowedUrls.find(function (u) {\n            return url.toLowerCase().startsWith(u.toLowerCase());\n          });\n        }\n\n        return true;\n      }\n    }, {\n      key: \"intercept\",\n      value: function intercept(req, next) {\n        var _this35 = this;\n\n        var url = req.url.toLowerCase();\n\n        if (!this.moduleConfig || !this.moduleConfig.resourceServer || !this.checkUrl(url)) {\n          return next.handle(req);\n        }\n\n        var sendAccessToken = this.moduleConfig.resourceServer.sendAccessToken;\n\n        if (!sendAccessToken) {\n          return next.handle(req).pipe(catchError(function (err) {\n            return _this35.errorHandler.handleError(err);\n          }));\n        }\n\n        return merge(of(this.oAuthService.getAccessToken()).pipe(filter(function (token) {\n          return !!token;\n        })), this.oAuthService.events.pipe(filter(function (e) {\n          return e.type === 'token_received';\n        }), timeout(this.oAuthService.waitForTokenInMsec || 0), catchError(function (_) {\n          return of(null);\n        }), // timeout is not an error\n        map(function (_) {\n          return _this35.oAuthService.getAccessToken();\n        }))).pipe(take(1), mergeMap(function (token) {\n          if (token) {\n            var header = 'Bearer ' + token;\n            var headers = req.headers.set('Authorization', header);\n            req = req.clone({\n              headers: headers\n            });\n          }\n\n          return next.handle(req).pipe(catchError(function (err) {\n            return _this35.errorHandler.handleError(err);\n          }));\n        }));\n      }\n    }]);\n\n    return DefaultOAuthInterceptor;\n  }();\n\n  DefaultOAuthInterceptor.ɵfac = function DefaultOAuthInterceptor_Factory(t) {\n    return new (t || DefaultOAuthInterceptor)(i0.ɵɵinject(OAuthService), i0.ɵɵinject(OAuthResourceServerErrorHandler), i0.ɵɵinject(OAuthModuleConfig, 8));\n  };\n\n  DefaultOAuthInterceptor.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DefaultOAuthInterceptor,\n    factory: DefaultOAuthInterceptor.ɵfac\n  });\n  return DefaultOAuthInterceptor;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\r\n * A validation handler that isn't validating nothing.\r\n * Can be used to skip validation (at your own risk).\r\n */\n\n\nvar NullValidationHandler = /*#__PURE__*/function () {\n  function NullValidationHandler() {\n    _classCallCheck(this, NullValidationHandler);\n  }\n\n  _createClass(NullValidationHandler, [{\n    key: \"validateSignature\",\n    value: function validateSignature(validationParams) {\n      return Promise.resolve(null);\n    }\n  }, {\n    key: \"validateAtHash\",\n    value: function validateAtHash(validationParams) {\n      return Promise.resolve(true);\n    }\n  }]);\n\n  return NullValidationHandler;\n}();\n\nfunction createDefaultLogger() {\n  return console;\n}\n\nfunction createDefaultStorage() {\n  return typeof sessionStorage !== 'undefined' ? sessionStorage : new MemoryStorage();\n}\n\nvar OAuthModule = /*#__PURE__*/(function () {\n  var OAuthModule = /*#__PURE__*/function () {\n    function OAuthModule() {\n      _classCallCheck(this, OAuthModule);\n    }\n\n    _createClass(OAuthModule, null, [{\n      key: \"forRoot\",\n      value: function forRoot() {\n        var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        var validationHandlerClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NullValidationHandler;\n        return {\n          ngModule: OAuthModule,\n          providers: [OAuthService, UrlHelperService, {\n            provide: OAuthLogger,\n            useFactory: createDefaultLogger\n          }, {\n            provide: OAuthStorage,\n            useFactory: createDefaultStorage\n          }, {\n            provide: ValidationHandler,\n            useClass: validationHandlerClass\n          }, {\n            provide: HashHandler,\n            useClass: DefaultHashHandler\n          }, {\n            provide: OAuthResourceServerErrorHandler,\n            useClass: OAuthNoopResourceServerErrorHandler\n          }, {\n            provide: OAuthModuleConfig,\n            useValue: config\n          }, {\n            provide: HTTP_INTERCEPTORS,\n            useClass: DefaultOAuthInterceptor,\n            multi: true\n          }, {\n            provide: DateTimeProvider,\n            useClass: SystemDateTimeProvider\n          }]\n        };\n      }\n    }]);\n\n    return OAuthModule;\n  }();\n\n  OAuthModule.ɵfac = function OAuthModule_Factory(t) {\n    return new (t || OAuthModule)();\n  };\n\n  OAuthModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: OAuthModule\n  });\n  OAuthModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return OAuthModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar err = \"PLEASE READ THIS CAREFULLY:\\n\\nBeginning with angular-oauth2-oidc version 9, the JwksValidationHandler\\nhas been moved to an library of its own. If you need it for implementing\\nOAuth2/OIDC **implicit flow**, please install it using npm:\\n\\n  npm i angular-oauth2-oidc-jwks --save\\n\\nAfter that, you can import it into your application:\\n\\n  import { JwksValidationHandler } from 'angular-oauth2-oidc-jwks';\\n\\nPlease note, that this dependency is not needed for the **code flow**,\\nwhich is nowadays the **recommented** one for single page applications.\\nThis also results in smaller bundle sizes.\\n\";\n/**\r\n * This is just a dummy of the JwksValidationHandler\r\n * telling the users that the real one has been moved\r\n * to an library of its own, namely angular-oauth2-oidc-utils\r\n */\n\nvar JwksValidationHandler = /*#__PURE__*/function (_NullValidationHandle) {\n  _inherits(JwksValidationHandler, _NullValidationHandle);\n\n  var _super6 = _createSuper(JwksValidationHandler);\n\n  function JwksValidationHandler() {\n    var _this36;\n\n    _classCallCheck(this, JwksValidationHandler);\n\n    _this36 = _super6.call(this);\n    console.error(err);\n    return _this36;\n  }\n\n  return _createClass(JwksValidationHandler);\n}(NullValidationHandler);\n\nvar AUTH_CONFIG = new InjectionToken('AUTH_CONFIG');\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { AUTH_CONFIG, AbstractValidationHandler, AuthConfig, DateTimeProvider, DefaultHashHandler, DefaultOAuthInterceptor, HashHandler, JwksValidationHandler, LoginOptions, MemoryStorage, NullValidationHandler, OAuthErrorEvent, OAuthEvent, OAuthInfoEvent, OAuthLogger, OAuthModule, OAuthModuleConfig, OAuthNoopResourceServerErrorHandler, OAuthResourceServerConfig, OAuthResourceServerErrorHandler, OAuthService, OAuthStorage, OAuthSuccessEvent, ReceivedTokens, SystemDateTimeProvider, UrlHelperService, ValidationHandler };","map":null,"metadata":{},"sourceType":"module"}