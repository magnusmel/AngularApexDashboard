{"ast":null,"code":"import _classCallCheck from \"/home/satyanayak610/Projects/Angular/AngularApexDashboard/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/satyanayak610/Projects/Angular/AngularApexDashboard/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/satyanayak610/Projects/Angular/AngularApexDashboard/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/satyanayak610/Projects/Angular/AngularApexDashboard/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport * as rs from 'jsrsasign';\nimport { AbstractValidationHandler } from 'angular-oauth2-oidc';\n/**\r\n * Validates the signature of an id_token against one\r\n * of the keys of an JSON Web Key Set (jwks).\r\n *\r\n * This jwks can be provided by the discovery document.\r\n */\n\nvar JwksValidationHandler = /*#__PURE__*/function (_AbstractValidationHa) {\n  _inherits(JwksValidationHandler, _AbstractValidationHa);\n\n  var _super = _createSuper(JwksValidationHandler);\n\n  function JwksValidationHandler() {\n    var _this;\n\n    _classCallCheck(this, JwksValidationHandler);\n\n    _this = _super.apply(this, arguments);\n    /**\r\n     * Allowed algorithms\r\n     */\n\n    _this.allowedAlgorithms = ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'PS256', 'PS384', 'PS512'];\n    /**\r\n     * Time period in seconds the timestamp in the signature can\r\n     * differ from the current time.\r\n     */\n\n    _this.gracePeriodInSec = 600;\n    return _this;\n  }\n\n  _createClass(JwksValidationHandler, [{\n    key: \"validateSignature\",\n    value: function validateSignature(params) {\n      var _this2 = this;\n\n      var retry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      if (!params.idToken) throw new Error('Parameter idToken expected!');\n      if (!params.idTokenHeader) throw new Error('Parameter idTokenHandler expected.');\n      if (!params.jwks) throw new Error('Parameter jwks expected!');\n\n      if (!params.jwks['keys'] || !Array.isArray(params.jwks['keys']) || params.jwks['keys'].length === 0) {\n        throw new Error('Array keys in jwks missing!');\n      } // console.debug('validateSignature: retry', retry);\n\n\n      var kid = params.idTokenHeader['kid'];\n      var keys = params.jwks['keys'];\n      var key;\n      var alg = params.idTokenHeader['alg'];\n\n      if (kid) {\n        key = keys.find(function (k) {\n          return k['kid'] === kid;\n        }\n        /* && k['use'] === 'sig' */\n        );\n      } else {\n        var kty = this.alg2kty(alg);\n        var matchingKeys = keys.filter(function (k) {\n          return k['kty'] === kty && k['use'] === 'sig';\n        });\n        /*\r\n              if (matchingKeys.length == 0) {\r\n                  let error = 'No matching key found.';\r\n                  console.error(error);\r\n                  return Promise.reject(error);\r\n              }*/\n\n        if (matchingKeys.length > 1) {\n          var error = 'More than one matching key found. Please specify a kid in the id_token header.';\n          console.error(error);\n          return Promise.reject(error);\n        } else if (matchingKeys.length === 1) {\n          key = matchingKeys[0];\n        }\n      }\n\n      if (!key && !retry && params.loadKeys) {\n        return params.loadKeys().then(function (loadedKeys) {\n          return params.jwks = loadedKeys;\n        }).then(function (_) {\n          return _this2.validateSignature(params, true);\n        });\n      }\n\n      if (!key && retry && !kid) {\n        var _error = 'No matching key found.';\n        console.error(_error);\n        return Promise.reject(_error);\n      }\n\n      if (!key && retry && kid) {\n        var _error2 = 'expected key not found in property jwks. ' + 'This property is most likely loaded with the ' + 'discovery document. ' + 'Expected key id (kid): ' + kid;\n\n        console.error(_error2);\n        return Promise.reject(_error2);\n      }\n\n      var keyObj = rs.KEYUTIL.getKey(key);\n      var validationOptions = {\n        alg: this.allowedAlgorithms,\n        gracePeriod: this.gracePeriodInSec\n      };\n      var isValid = rs.KJUR.jws.JWS.verifyJWT(params.idToken, keyObj, validationOptions);\n\n      if (isValid) {\n        return Promise.resolve();\n      } else {\n        return Promise.reject('Signature not valid');\n      }\n    }\n  }, {\n    key: \"alg2kty\",\n    value: function alg2kty(alg) {\n      switch (alg.charAt(0)) {\n        case 'R':\n          return 'RSA';\n\n        case 'E':\n          return 'EC';\n\n        default:\n          throw new Error('Cannot infer kty from alg: ' + alg);\n      }\n    }\n  }, {\n    key: \"calcHash\",\n    value: function calcHash(valueToHash, algorithm) {\n      var hashAlg = new rs.KJUR.crypto.MessageDigest({\n        alg: algorithm\n      });\n      var result = hashAlg.digestString(valueToHash);\n      var byteArrayAsString = this.toByteArrayAsString(result);\n      return Promise.resolve(byteArrayAsString);\n    }\n  }, {\n    key: \"toByteArrayAsString\",\n    value: function toByteArrayAsString(hexString) {\n      var result = '';\n\n      for (var i = 0; i < hexString.length; i += 2) {\n        var hexDigit = hexString.charAt(i) + hexString.charAt(i + 1);\n        var num = parseInt(hexDigit, 16);\n        result += String.fromCharCode(num);\n      }\n\n      return result;\n    }\n  }]);\n\n  return JwksValidationHandler;\n}(AbstractValidationHandler);\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { JwksValidationHandler }; //# sourceMappingURL=angular-oauth2-oidc-jwks.mjs.map","map":null,"metadata":{},"sourceType":"module"}